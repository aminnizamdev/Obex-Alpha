
'PROJECT_ROOT'>ALPHA_III_SPEC.md
α‑III — Admission Engine Specification

Canonical Transaction Bytes (TxBodyV1)
- Bytes = H("obex.tx.body.v1", []) ||
  sender(32) || recipient(32) || LE(nonce,8) || LE(amount_u,16) || LE(fee_u,16) ||
  LE(s_bind,8) || y_bind(32) || encode_access(access) || LE(memo_len,4) || memo.

Access List Encoding
- access_bytes = H("obex.tx.access", []) || LE(|read|,4) || read_accounts*32 || LE(|write|,4) || write_accounts*32.
- Sort & dedup read and write lists before encoding.

Identifiers & Signature
- txid = H("obex.tx.id", [ canonical_tx_bytes ]).
- commit_hash = H("obex.tx.commit", [ canonical_tx_bytes ]).
- Signature message = H("obex.tx.sig", [ canonical_tx_bytes ]); Ed25519 verify_strict with sender pk.

Fee Rule (u128 arithmetic)
- If amount_u ≤ 1,000 → fee = 10; else fee = ceil(amount_u / 100).
- Reject if provided fee_u != computed.

Admission State & Steps
- Maps: spendable_u[pk], reserved_u[pk], next_nonce[pk], admitted_by_slot[s], tickets_by_txid.
- Steps for tx at slot s_now with beacon y_prev:
  1) verify signature; 2) s_bind == s_now; 3) y_bind == y_prev;
  4) nonce == next_nonce[sender]; 5) amount_u ≥ MIN_TX_UOBX; 6) fee_u matches rule;
  7) spendable ≥ amount_u + fee_u → move to reserved; increment nonce.
- Result: Finalized(TicketRecord) or Rejected(reason).

TicketRecord & Root
- TicketRecord fields: ticket_id(32), txid(32), sender(32), LE(nonce,8), LE(amount_u,16), LE(fee_u,16), LE(s_admit,8), LE(s_exec,8), commit_hash(32).
- ticket_id = H("obex.ticket.id", [ txid, LE(s_admit,8) ]).
- Leaf = H("obex.ticket.leaf", []) || canonical fields; per‑slot root = Merkle over leaves sorted by txid.

Reject Reasons
- BadSig, WrongSlot, WrongBeacon, NonceMismatch, BelowMinAmount, FeeMismatch, InsufficientFunds.

Golden Artifacts (α‑III)
- ticket_leaves.bin (concat), ticket_root.bin, fee_edges.json with edge cases, negatives/* (bad fee, bad nonce, bad signature).



'PROJECT_ROOT'>ALPHA_II_AND_VDF_SPEC.md
α‑II — Header & Beacon (VDF) Specification

Header Object
- Fields:
  - parent_id: [u8;32]
  - slot: u64 LE
  - obex_version: u32 LE (= OBEX_ALPHA_II_VERSION)
  - seed_commit: [u8;32] where seed_commit == H("obex.slot.seed", [ parent_id, LE(slot,8) ])
  - vdf_y_core: [u8;32] (Hash256 per current implementation)
  - vdf_y_edge: [u8;32] (Hash256 per current implementation)
  - vdf_pi: bytes with u32 LE length prefix (cap MAX_PI_LEN)
  - vdf_ell: bytes with u32 LE length prefix (cap MAX_ELL_LEN)
  - ticket_root: [u8;32]
  - part_root: [u8;32]
  - txroot_prev: [u8;32]

Header Identity
- HeaderID = H("obex.header.id", [
  parent_id,
  LE(slot,8),
  LE(obex_version,4),
  seed_commit,
  vdf_y_core,
  vdf_y_edge,
  LE(|vdf_pi|,4), vdf_pi,
  LE(|vdf_ell|,4), vdf_ell,
  ticket_root,
  part_root,
  txroot_prev
]).

Build Header (s = parent.slot + 1)
- Inputs: seed_commit, y_core, y_edge, pi, ell; providers for ticket_root(s), part_root(s), txroot(s−1).
- Set parent_id = HeaderID(parent).

Validation (must pass all)
1) parent_id equality; 2) slot == parent.slot + 1; 3) version match.
4) size caps for vdf_pi, vdf_ell.
5) seed_commit recompute and equality.
6) Beacon verify(inputs) == true.
7) ticket_root(participation/admission) equalities; 8) txroot_prev equality.

Beacon v1 — Hash‑Edge Adapter (frozen for testnet)
Definition (normative)
- Sizes: `vdf_y_core` and `vdf_y_edge` are 32 bytes (Hash256). `vdf_pi` length MUST be 0. `vdf_ell` length MUST be 0.
- Equality: `vdf_y_edge == H("obex.vdf.edge", [ vdf_y_core ])`.

Validation additions
- Enforce `vdf_pi.len() == 0` and `vdf_ell.len() == 0`.
- Enforce the hash‑edge equality above.

Future VDF
- A class‑group Wesolowski backend can be added in a future network version bump with new goldens. That change will require explicit versioning and coordinated rollout; it is out of scope for testnet v1.

Verifier Contract
```
fn vdf_verify(
  seed_commit: &[u8;32],
  T_le: [u8;8],
  y_core: &[u8],
  y_edge: &[u8],
  pi: &[u8],
  ell: &[u8],
) -> bool
```
- Steps: size checks → transcript → ell → Wesolowski multi‑exp check → boolean.

Calibration & KATs
- Calibrate T on a reference machine; set conservative T; publish vectors: (seed_commit, T, g, y_core, y_edge, pi, ell) with negatives (corrupted size/ell/T/edge).



'PROJECT_ROOT'>ALPHA_I_SPEC.md
α‑I — Participation Engine Specification

Overview
- Provides VRF‑salted RAM‑hard verification with Q=96 challenges and a canonical participation record (ObexPartRec). Produces the participation set P_s and commitment part_root_s.

Parameters (as implemented)
- MEM_MIB = 512, LABEL_BYTES = 32, N_LABELS = 16,777,216 (2^24), PASSES = 3, CHALLENGES_Q = 96.
- MAX_PARTREC_SIZE = 600,000 bytes (pre‑crypto cap).

VRF
- Suite: RFC 9381 ECVRF‑EDWARDS25519‑SHA512‑TAI.
- Encodings: pk 32, proof π 80, output y 64 bytes.
- Alpha (32 bytes): alpha32 = H("obex.alpha", [ parent_id(32), LE(slot,8), y_edge_prev(32), vrf_pk(32) ]).
- Verifier interface returns Option<[u8;64]>; None on any failure.

Seed & Labeling
- seed = H("obex.seed", [ y_edge_prev, pk_ed25519, vrf_y ]).
- idx_j = f(seed,i,p,0x00); idx_k = f(seed,i,p,0x01) via tag "obex.idx" with LE(i,8), LE(p,4), and a domain byte.
- lbl_i = H("obex.lbl", [ seed, LE(i,8), l_{i-1}, l_j, l_k ]).

Challenge Index
- i_t = 1 + ( LE64( H("obex.chal", [ y_edge_prev, root, vrf_y, LE(t,4) ])[..8] ) mod (N_LABELS − 1) ).

Merkle
- Root over 32‑byte labels with duplicate‑last; empty = H("obex.merkle.empty", []).
- Leaf = H("obex.merkle.leaf", [ label ]). Node = H("obex.merkle.node", [ L||R ]).
- Verify leaf at index using siblings list and index parity per level.

Canonical Participation Record (ObexPartRec)
- Encoding (all integers LE; order exact):
  1) version: u32
  2) slot: u64
  3) pk_ed25519: [u8;32]
  4) vrf_pk: [u8;32]
  5) y_edge_prev: [u8;32]
  6) alpha: [u8;32]
  7) vrf_y: [u8;64]
  8) vrf_pi: [u8;80]
  9) seed: [u8;32]
 10) root: [u8;32]
 11) challenges_count: u32 (=96)
 12) for each of 96 challenges (ChallengeOpen):
     - idx: u64
     - li: [u8;32]; pi_siblings_len: u32; siblings: 32×len
     - lim1: [u8;32]; pim1_len: u32; siblings: 32×len
     - lj: [u8;32]; pj_len: u32; siblings: 32×len
     - lk: [u8;32]; pk_len: u32; siblings: 32×len
 13) sig: [u8;64] (Ed25519 verify_strict over transcript)

Transcript for Signature
- msg = H("obex.partrec", [ LE(version,4), pk_ed25519(32), vrf_pk(32), LE(slot,8), y_edge_prev(32), alpha(32), vrf_y(64), root(32) ]).

Verification Steps
1) Bounds: size ≤ MAX_PARTREC_SIZE; version, slot, challenges count.
2) alpha recompute; VRF verify → y check; seed recompute.
3) Signature verify_strict over transcript.
4) For each challenge: range checks; Merkle verify li at i, lim1 at i−1, lj at j, lk at k; label equation l_i = lbl(seed,i,l_{i−1},l_j,l_k).

Participation Set & Root
- Deduplicate pk_ed25519 across valid records for slot s; sort ascending.
- Leaf bytes for set: H("obex.part.leaf", []) || pk; root = Merkle over leaves.

Reject Reasons (stable)
- VersionMismatch, SlotMismatch, ChallengesLen, AlphaMismatch, VrfVerifyFailed, VrfOutputMismatch, SeedMismatch, SigInvalid, ChalIndexMismatch, ChalIndexBounds, JOrKOutOfRange, MerkleLiInvalid, MerkleLim1Invalid, MerkleLjInvalid, MerkleLkInvalid, LabelEquationMismatch, Oversize.

Golden Artifacts (α‑I)
- partrec.bin (full), vrf_output.bin (64), vrf_proof.bin (80), root.bin (32), P_s.root.bin (32), negatives/* (corrupt size/indices/labels/signature).



'PROJECT_ROOT'>ALPHA_T_SPEC.md
α‑T — Tokenomics Specification

Emission Schedule
- Total supply in μOBX; per‑slot payout uses accumulator arithmetic with halving periods.
- On each slot: acc_num += R0_NUM; payout = floor(acc_num / den(period)); credit emission; acc_num -= payout * den.
- At terminal slot: flush residual to hit exact total supply; assert total emitted equals TOTAL_SUPPLY_UOBX.

Fee Split (NLB)
- Epoch length NLB_EPOCH_SLOTS; on epoch roll: snapshot effective supply; compute split percents (verifier/treasury/burn) based on supply thresholds.
- Route fees with numerator/denominator (10k basis‑point scheme) and escrow cap; release cannot exceed escrow.

DRP (Distributed Reward Protocol)
- Baseline share evenly across participation set; lottery across K winners with unique indices derived from beacon draw H("obex.reward.draw", [ y_edge, LE(slot,8), LE(t,4) ]).
- Reward payout ordering by H("obex.reward.rank", [ y_edge, pk ]) ascending.

System Transactions & Ordering
- SysTx kinds: EscrowCredit, EmissionCredit, VerifierCredit, TreasuryCredit, Burn, RewardPayout.
- Canonical within‑slot ordering: Escrow → Emission → Verifier → Treasury → Burn → RewardPayout (where RewardPayouts are rank‑sorted).

Invariants
- Emission monotone; escrow conservation; splits respect escrow; burn reduces effective supply snapshot for next epoch.

Golden Artifacts (α‑T)
- Emission sampling traces; sys_tx golden encode/decode; ordering tests; fee‑split epoch roll cases.



'PROJECT_ROOT'>API_ENDPOINTS.md
HTTP API Endpoints (Minimal Testnet)

GET /alpha_i/{slot}/{pk}
- Request: slot (u64 decimal), pk (hex 64)
- Response: application/octet-stream; body = canonical ObexPartRec bytes
- Status:
  - 200 OK: body present
  - 404 Not Found: no record for pk at slot
  - 413 Payload Too Large: record exceeds MAX_PARTREC_SIZE

GET /alpha_iii/{slot}
- Request: slot (u64 decimal)
- Response: application/octet-stream; body = concatenated TicketRecord leaf bytes for slot
- Status:
  - 200 OK: body present (may be empty)
  - 404 Not Found: no tickets recorded for slot

GET /tx/{txid} (optional)
- Request: txid (hex 64)
- Response: canonical tx bytes

Metrics (optional)
- GET /metrics → OpenMetrics text; includes header validation counts, timings, fetch failures.

Notes
- All binary payloads are consensus‑canonical encodings; clients must apply size caps before decode.



'PROJECT_ROOT'>BYTE_LAYOUTS.md
Byte Layouts (Offsets & Sizes)

Notation
- LE(n): n-byte little-endian integer; [x;y]: inclusive-exclusive byte range.
- Tags are 32-byte SHA3-256 digests of the domain tag strings applied by H(...); when included literally we denote them as TagBytes(tag).

α‑I — ObexPartRec (encode_partrec)
Order and sizes (all integers little-endian):
1) version: LE(4)                [0;4)
2) slot: LE(8)                   [4;12)
3) pk_ed25519: 32                [12;44)
4) vrf_pk: 32                    [44;76)
5) y_edge_prev: 32               [76;108)
6) alpha: 32                     [108;140)
7) vrf_y: 64                     [140;204)
8) vrf_pi: 80                    [204;284)
9) seed: 32                      [284;316)
10) root: 32                     [316;348)
11) challenges_len: LE(4)        [348;352) (=96)
12) challenges: repeated blocks, each:
    a) idx: LE(8)
    b) li: 32; pi_len: LE(4); pi_siblings: 32×pi_len
    c) lim1: 32; pim1_len: LE(4); pim1_siblings: 32×pim1_len
    d) lj: 32; pj_len: LE(4); pj_siblings: 32×pj_len
    e) lk: 32; pk_len: LE(4); pk_siblings: 32×pk_len
13) sig: 64                      [end-64; end)

Transcript bytes (for signature msg):
msg = H("obex.partrec", [ LE(version,4), pk_ed25519(32), vrf_pk(32), LE(slot,8), y_edge_prev(32), alpha(32), vrf_y(64), root(32) ])

α‑III — TicketRecord Leaf (enc_ticket_leaf)
LeafBytes = TagBytes("obex.ticket.leaf") ||
  ticket_id(32) || txid(32) || sender(32) || LE(nonce,8) || LE(amount_u,16) || LE(fee_u,16) || LE(s_admit,8) || LE(s_exec,8) || commit_hash(32)

α‑III — Access Encoding
access_bytes = TagBytes("obex.tx.access") || LE(|read|,4) || read_accounts*32 || LE(|write|,4) || write_accounts*32

α‑III — Tx Canonical Bytes
tx_bytes = TagBytes("obex.tx.body.v1") || sender(32) || recipient(32) || LE(nonce,8) || LE(amount_u,16) || LE(fee_u,16) || LE(s_bind,8) || y_bind(32) || access_bytes || LE(memo_len,4) || memo

α‑II — Header Serialization (serialize_header)
1) parent_id: 32
2) slot: LE(8)
3) obex_version: LE(4)
4) seed_commit: 32
5) vdf_y_core: 32 (placeholder; to be updated if VDF sizes fixed larger)
6) vdf_y_edge: 32
7) |vdf_pi|: LE(4) then vdf_pi bytes
8) |vdf_ell|: LE(4) then vdf_ell bytes
9) ticket_root: 32
10) part_root: 32
11) txroot_prev: 32

HeaderID inputs use the same field order, but lengths for vdf buffers are included explicitly as LE(4) before their data.

Merkle Node Concatenation
- For node hash: cat = left(32) || right(32) → H("obex.merkle.node", [ cat ])

Note
- Offsets for variable-length sections depend on sibling counts; verify bounds against MAX_PARTREC_SIZE and per-field length prefixes before parsing.



'PROJECT_ROOT'>CONFORMANCE_MATRIX.md
Conformance Matrix (Spec → Code → Test)

Purpose
- Ensures every normative rule in the spec is implemented and tested, with exact code anchors.

Legend
- S: Spec section; C: Code function/path; T: Test(s)/goldens.

Examples

S CONSENSUS_SPEC.md/Hashing →
- C `crates/obex_primitives/src/lib.rs::h_tag`, `consensus.rs::h_tag`
- T `crates/obex_primitives/tests/kats.rs` (tag ASCII checks)

S α‑I/Alpha derivation →
- C `crates/obex_alpha_i/src/lib.rs::obex_alpha`
- T `crates/obex_alpha_i/tests/gating.rs`

S α‑I/PartRec codec →
- C `crates/obex_alpha_i/src/lib.rs::encode_partrec/decode_partrec`
- T `crates/obex_alpha_i/tests/golden.rs` (round‑trip)

S α‑II/HeaderID (field‑wise hash, not serialized bytes) →
- C `crates/obex_alpha_ii/src/lib.rs::obex_header_id`
- T `crates/obex_alpha_ii/tests/golden_header.rs`

S α‑III/Access encoding →
- C `crates/obex_alpha_iii/src/lib.rs::encode_access`
- T `crates/obex_alpha_iii/tests/gating.rs`

S α‑T/System tx ordering →
- C `crates/obex_alpha_t/src/lib.rs::canonical_sys_tx_order`
- T `crates/obex_alpha_t/tests/golden.rs`

S α‑II/seed_commit equality →
- C `crates/obex_alpha_ii/src/lib.rs::validate_header`
- T `crates/e2e/tests/equalities.rs::validate_header_with_nonempty_roots`

S α‑II/beacon v1 adapter (pi/ell empty, edge == H(edge,[core])) →
- C `crates/obex_alpha_ii/src/lib.rs::validate_header`
- T `crates/obex_alpha_ii/tests/negatives.rs::{beacon_v1_edge_mismatch_rejected, beacon_v1_nonempty_proofs_rejected}`

S α‑II/ticket_root equality →
- C `crates/obex_alpha_ii/src/lib.rs::validate_header`
- T `crates/e2e/tests/equalities.rs::validate_header_with_nonempty_roots`

S α‑II/part_root equality →
- C `crates/obex_alpha_ii/src/lib.rs::validate_header`
- T `crates/e2e/tests/equalities.rs::validate_header_with_nonempty_roots`

S α‑II/txroot_prev equality →
- C `crates/obex_alpha_ii/src/lib.rs::validate_header`
- T `crates/e2e/tests/equalities.rs::validate_header_with_nonempty_roots`

S α‑III/Fee rule edges →
- C `crates/obex_alpha_iii/src/lib.rs::fee_int`
- T `crates/obex_alpha_iii/tests/admission.rs::fee_rule_edges`

S α‑III/Ticket leaf size (enc_ticket_leaf == 216 bytes) →
- C `crates/obex_alpha_iii/src/lib.rs::enc_ticket_leaf`
- T `crates/obex_alpha_iii/tests/admission.rs::ticket_leaf_length_is_216_bytes`

S α‑T/Emission terminal flush →
- C `crates/obex_alpha_t/src/lib.rs::on_slot_emission`
- T `crates/obex_alpha_t/tests/tokenomics.rs::emission_monotone_and_terminal_flush`

S DoS caps (α‑I size, α‑II VDF size caps) →
- C `crates/obex_alpha_i/src/lib.rs::MAX_PARTREC_SIZE`, `crates/obex_alpha_ii/src/lib.rs::{MAX_PI_LEN, MAX_ELL_LEN}`
- T `crates/obex_alpha_i/tests/fuzz_decode.rs`, `crates/obex_alpha_ii/tests/negatives.rs`



'PROJECT_ROOT'>CONSENSUS_SPEC.md
OBEX Alpha — Consensus Specification (Normative)

Scope
- This document freezes consensus rules for hashing, domain tags, encodings, endianness, and Merkle behavior. All α‑I/II/III/T engines must conform byte‑for‑byte.

Hashing Discipline
- Hash function: SHA3‑256 with 32‑byte output.
- Domain separation: every consensus hash uses an ASCII tag in the `obex.*` namespace.
- Length framing: H(tag, parts[]) = SHA3_256( UTF8(tag) || Σ ( LE(|p|,8) || p ) ).
- Constant‑time equality: 32‑byte digests compared with constant‑time equality.

Endianness & Integer Widths
- All on‑wire integers are little‑endian (LE).
- Widths: u32 (4 bytes), u64 (8 bytes), u128 (16 bytes). Length prefixes for variable bytes are u32 LE.

Tag Registry (must match code)
- obex.merkle.leaf, obex.merkle.node, obex.merkle.empty
- obex.alpha, obex.part.leaf, obex.partrec, obex.seed, obex.l0, obex.lbl, obex.idx, obex.chal, obex.vrfy
- obex.header.id, obex.slot.seed, obex.vdf.ycore, obex.vdf.edge
- obex.tx.access, obex.tx.body.v1, obex.tx.id, obex.tx.commit, obex.tx.sig, obex.txid.leaf
- obex.ticket.id, obex.ticket.leaf
- obex.sys.tx, obex.reward.draw, obex.reward.rank

Merkle Rules
- Binary tree; when a level has odd length, duplicate the last node.
- Empty root = H("obex.merkle.empty", []).
- Leaf = H("obex.merkle.leaf", [ payload ]), where payload is the canonical leaf bytes (32‑byte label for α‑I; tagged ticket leaf bytes for α‑III).
- Node = H("obex.merkle.node", [ left(32) || right(32) ]).
- Authentication path: siblings from leaf to root; recomputation places the current hash left or right by leaf index parity per level.

Header Identity (α‑II)
- HeaderID = H("obex.header.id", [ field‑wise values and lengths as defined in α‑II spec ]). The ID is a hash of field values, not of serialization bytes.

Reject Semantics
- Fail‑closed: any mismatch or size violation rejects the object.
- Enforce size caps before any cryptographic verification.

Versions (as implemented)
- OBEX_ALPHA_I_VERSION = 1 (u32)
- OBEX_ALPHA_II_VERSION = 2 (u32)
- OBEX_ALPHA_III_VERSION = 1 (u32)
- OBEX_ALPHA_T_VERSION = 1 (u32)

DoS Bounds (global)
- Enforce α‑I record size ≤ 600,000 bytes prior to decode.
- Enforce α‑II `vdf_pi` ≤ MAX_PI_LEN, `vdf_ell` ≤ MAX_ELL_LEN prior to beacon verification.
- Enforce header serialized bytes ≤ implementation cap (≤ 4 KiB recommended).



'PROJECT_ROOT'>ERRORS_AND_CODES.md
Stable Errors and Numeric Codes

Purpose
- Provide stable, loggable codes for reject reasons to aid interoperability and debugging.

HeaderReject (α‑II)
- 100 VersionMismatch
- 101 BadParentLink
- 102 BadSlot
- 103 VdfPiTooBig
- 104 VdfEllTooBig
- 105 BadSeedCommit
- 106 BeaconInvalid
- 107 TicketRootMismatch
- 108 PartRootMismatch
- 109 TxRootPrevMismatch

AlphaIReject (α‑I)
- 200 VersionMismatch
- 201 SlotMismatch
- 202 ChallengesLen
- 203 AlphaMismatch
- 204 VrfVerifyFailed
- 205 VrfOutputMismatch
- 206 SeedMismatch
- 207 SigInvalid
- 208 ChalIndexMismatch
- 209 ChalIndexBounds
- 210 JOrKOutOfRange
- 211 MerkleLiInvalid
- 212 MerkleLim1Invalid
- 213 MerkleLjInvalid
- 214 MerkleLkInvalid
- 215 LabelEquationMismatch
- 216 Oversize

AdmissionReject (α‑III)
- 300 BadSig
- 301 WrongSlot
- 302 WrongBeacon
- 303 NonceMismatch
- 304 BelowMinAmount
- 305 FeeMismatch
- 306 InsufficientFunds

Logging Guidance
- Log `{ code, reason, slot, header_id?, txid?, pk? }` as structured JSON; never include private keys or secrets.



'PROJECT_ROOT'>GOLDENS_AND_TESTING.md
Golden Vectors & Testing Strategy

Golden Directories
- tests/golden/vdf/: seed_commit.bin (32), y_core.bin (32), y_edge.bin (32), pi.bin (0), ell.bin (0), negatives/*
- tests/golden/alpha_i/: pk.bin, vrf_output.bin (64), vrf_proof.bin (80), root.bin, partrec.bin, P_s.root.bin, negatives/*
- tests/golden/alpha_iii/: ticket_leaves.bin (concat), ticket_root.bin, fee_edges.json, negatives/*
- tests/golden/header/: header.bin (serialized), header_id.bin, negatives/*

Rules
- Goldens are authoritative; tests recompute and compare byte‑for‑byte.
- Negatives mutate exactly one field; tests assert rejection (for beacon v1 include y_edge ≠ H(obex.vdf.edge, [y_core]) and non‑zero pi/ell).

Unit Tests
- Hashing/tagging, Merkle empty/duplicate‑last, α‑I indices/label equations, α‑III fee edges, α‑T invariants.

Fuzzing (manual/nightly)
- registration_decode, registration_verify; add header_decode, tx_decode, vdf_transcript.

E2E 3‑slot Pipeline
- Build/validate chain over slots s−1, s, s+1 with fixed inputs; assert exactly one valid header per (parent,s).

Performance Gates
- vdf_verify ≤ 10 ms; α‑I verify (Q=96) ≤ 60–70 ms; ticket_root ≤ 20 ms; header_validate ≤ 100 ms (reference box).



'PROJECT_ROOT'>GOLDEN_MANIFEST.md
Golden Manifest (Files, Sizes, Checksums)

Purpose
- This manifest lists every golden artifact required for byte-precise conformance. Use it to generate, verify, and publish goldens.

Format
- JSON index `tests/golden/index.json` with entries:
```
{
  "vdf": {
    "seed_commit.bin":  { "bytes": 32,     "sha256": "..." },
    "y_core.bin":       { "bytes": 32,     "sha256": "..." },
    "y_edge.bin":       { "bytes": 32,     "sha256": "..." },
    "pi.bin":           { "bytes": 0,      "sha256": "..." },
    "ell.bin":          { "bytes": 0,      "sha256": "..." }
  },
  "alpha_i": {
    "pk.bin":           { "bytes": 32, "sha256": "..." },
    "vrf_output.bin":   { "bytes": 64, "sha256": "..." },
    "vrf_proof.bin":    { "bytes": 80, "sha256": "..." },
    "root.bin":         { "bytes": 32, "sha256": "..." },
    "partrec.bin":      { "bytes": "<=600000", "sha256": "..." },
    "P_s.root.bin":     { "bytes": 32, "sha256": "..." }
  },
  "alpha_iii": {
    "ticket_leaves.bin": { "bytes": "var", "sha256": "..." },
    "ticket_root.bin":   { "bytes": 32, "sha256": "..." }
  },
  "header": {
    "header.bin":     { "bytes": "<=4096", "sha256": "..." },
    "header_id.bin":  { "bytes": 32, "sha256": "..." }
  },
  "negatives": [ "..." ]
}
```

Rules
- All files are immutable once published for a given testnet tag; any change requires new tag and version bump where applicable.



'PROJECT_ROOT'>IMPLEMENTATION_CHECKLIST.md
Implementation Checklist (Rebuild Without Drift)

Consensus & Constants
- [ ] Freeze tags and constants (CONSENSUS_SPEC.md) as single source of truth.
- [ ] Audit all hashes use `obex.*` tags.

α‑I
- [ ] Implement VRF adapter (RFC 9381) returning 64‑byte y for 80‑byte π.
- [ ] Implement alpha/seed/label/index functions verbatim.
- [ ] Implement encode/decode_partrec with size cap; transcript and signature verify.
- [ ] Implement build_participation_set and root.
- [ ] KATs: partrec round‑trip; negative cases.

α‑II + VDF
- [ ] Implement header struct, serializer, `obex_header_id` as field‑wise hash.
- [ ] Implement providers and validation equalities.
- [ ] Implement VDF `vdf_verify` adapter; calibrate T; add vectors.

α‑III
- [ ] Implement canonical tx bytes, ids, commit, signature.
- [ ] Implement fee rule; admission flow; ticket leaves and root.

α‑T
- [ ] Implement emission accumulator; NLB fee splits; DRP; sys tx ordering.

Networking
- [ ] Implement header‑first pipeline and HTTP endpoints per NETWORKING_AND_AVAILABILITY.md.

Goldens & Tests
- [ ] Generate vdf, alpha_i, alpha_iii, header goldens; add negatives.
- [ ] Add E2E 3‑slot pipeline test; benches with gates.

Packaging
- [ ] Produce genesis.toml, binaries, SHA256; publish peers.

Release
- [ ] Burn‑in 10k slots on 5‑node devnet; zero divergence; tag release.



'PROJECT_ROOT'>NETWORKING_AND_AVAILABILITY.md
Networking & Availability Policy (Header‑First)

Goals
- Deterministic header validation with body/proof fetch on demand; bounded resource usage; reproducible roots locally.

Header‑First Flow
1) Receive header candidate h.
2) Check parent link, slot, version, size caps.
3) Verify seed_commit; run beacon.verify (after size checks).
4) If any root non‑empty: fetch required bodies to recompute locally.

HTTP Endpoints (minimal)
- GET /alpha_i/{slot}/{pk} → application/octet‑stream
  - Returns canonical ObexPartRec bytes for participant pk at slot.
  - Reject if size > MAX_PARTREC_SIZE.
- GET /alpha_iii/{slot} → application/octet‑stream
  - Returns concatenated canonical ticket bytes (TicketRecord leaf bytes) for slot.
- Optional GET /tx/{txid} for audit.

Backpressure & Limits
- Per peer per slot: ≤ 1 ObexPartRec per pk; max concurrent fetches per slot configurable.
- Rate‑limit re‑requests; exponential backoff on failures.

Failure Handling
- Missing bodies or invalid bodies → header invalid/unverifiable; do not finalize.

Logging & Metrics
- Log fetch start/end with slot and header_id; count failures by endpoint and reason.



'PROJECT_ROOT'>NODE_AND_GENESIS.md
Node, Genesis & Packaging

Node (obex‑node)
- Responsibilities: header‑first validation, fetch bodies/proofs, recompute roots, schedule slots, persist headers/state, expose minimal HTTP endpoints, metrics/logs.
- Storage: append‑only headers by slot; participation set cache; per‑slot ticket sets.
- Scheduler: tick every SLOT_MS; process incoming headers out‑of‑order by caching until parent available.

Genesis
- genesis.toml contents:
  - network_id (string)
  - genesis_header_id (hex)
  - versions: α‑I/II/III/T
  - VDF: delta_bits, g (base64), T (LE8)
  - Fees: min/flat/switch

Packaging
- Static binaries for linux‑x86_64 and aarch64; provide SHA256 sums; publish genesis.toml and peer seeds.
- Dockerfile/Compose to run a 5‑node devnet locally.

Operator Guide
- Startup: `obex-node --genesis genesis.toml --data-dir ... --listen 0.0.0.0:PORT`.
- Telemetry: scrape `/metrics` (OpenMetrics format) or log tail JSON.
- Health: consistent header IDs across nodes per slot.



'PROJECT_ROOT'>OPS_SECURITY_PERF_BUILD.md
Ops, Security, Performance, Build Workflow

Security
- No `unsafe`; constant‑time verification where applicable; fail‑fast size caps before crypto.
- Key hygiene: zeroize secrets in tooling; consensus paths never carry private keys.
- Reporting: security contact, responsible disclosure (see README Security).

Performance
- Benchmarks with gates on reference hardware; document floor on low‑end.
- Profile α‑I hot paths (Merkle verify, label equation) and header validation.

Build Workflow (Solo, No CI)
- Before tagging or regenerating goldens:
  1) cargo fmt --all
  2) cargo clippy --all-targets --all-features -D warnings
  3) cargo build --locked
  4) cargo test --workspace --all-features
  5) cargo test -p e2e -- --ignored golden
- Optional nightly fuzz for decode paths.

Release Checklist
- Freeze constants; regenerate goldens; tag release; publish binaries + SHA256; publish genesis and peers.



'PROJECT_ROOT'>PERF_GATES.md
Performance Gates & Reference Hardware

Reference Box
- CPU: i5-12400 or Ryzen 5 5600; RAM: 16 GB; OS: Linux x86-64; Rust stable.

Targets (95th percentile)
- vdf_verify: ≤ 10 ms
- α‑I verify (Q=96): ≤ 70 ms
- ticket_root build (200 leaves): ≤ 20 ms
- header_validate end‑to‑end: ≤ 100 ms

Low-End Floor
- Allow up to 2× reference (document measured values).

Benchmarking
- Use Criterion; assert under gates in non-dev bench mode; export summaries.

Regression Policy
- If a gate is exceeded, investigate and either optimize or bump the gate with justification (requires new tag before public net).



'PROJECT_ROOT'>PUBLIC_TESTNET_PLAN.md
OBEX Alpha — Public Testnet Plan (Byte‑Precise, Production‑Grade)

Status: Draft for implementation; aligned to current α‑I/II/III/T crates. This plan does not change any existing files; it specifies exactly what to freeze, implement, and verify to reach a world‑class public testnet.

Table of Contents
- Scope and Principles
- Consensus Discipline (Hashing, Tags, Endianness)
- One Source of Truth (Constants and Versions)
- α‑I Participation (VRF + RAM‑Hard + Merkle)
- α‑II Header (Deterministic Equalities + VDF Adapter)
- VDF Backend Freeze (Wesolowski) — Transcript, Sizes, KATs
- α‑III Admission (Tx Canonical Bytes, Fees, Tickets, Root)
- α‑T Tokenomics (Emission, NLB Fee Splits, DRP, SysTx Order)
- Networking & Availability Policy (Header‑First + Fetch)
- Golden Vectors (Format and Coverage)
- Testing Strategy (Unit, Fuzz, E2E, Golden, Perf Gates)
- Observability (Metrics, Logs, Reject Codes)
- Genesis & Packaging (Configs, Binaries, Devnet → Public Testnet)
- Solo Developer Workflow (No CI)
- Execution Roadmap (Tasks and Milestones)
- Appendices (Tag Registry, Sizes, Byte Layouts)

—

Scope and Principles
- Objective: Launch a deterministic, equality‑validated, VRF‑based public testnet, with frozen hashing/tagging rules, reproducible byte encodings, and comprehensive golden vectors.
- Non‑goals: Smart contract layer, permanent storage engine selection, P2P opcodes beyond minimum viable header‑first gossip.
- Guidance: Favor current α‑I/II/III/T code as normative; reconcile docs to code where divergences exist.

—

Consensus Discipline (Hashing, Tags, Endianness)
- Hash function: SHA3‑256 only in consensus paths.
- Domain separation: Every consensus hash uses a stable ASCII tag in the `obex.*` namespace.
- Length framing: H(tag, parts[]) = SHA3‑256( UTF8(tag) || Σ ( LE(|p|,8) || p ) ).
- Endianness: Keep existing little‑endian fixed‑width integer encodings throughout (u32/u64/u128 as implemented in α‑crates and primitives). Length fields used by serializers are u32 LE.
- Zero unsafe: `#![forbid(unsafe_code)]`, reject on warnings.

—

One Source of Truth (Constants and Versions)
Authoritative definitions live in `crates/obex_primitives`:
- Tag registry: see Appendix A.
- Version constants (as of code today):
  - OBEX_ALPHA_I_VERSION = 1 (u32)
  - OBEX_ALPHA_II_VERSION = 2 (u32)
  - OBEX_ALPHA_III_VERSION = 1 (u32)
  - OBEX_ALPHA_T_VERSION = 1 (u32)
- α‑I parameters (as implemented):
  - MEM_MIB = 512
  - LABEL_BYTES = 32
  - N_LABELS = (MEM_MIB · 1,048,576) / 32 = 16,777,216 (2^24)
  - PASSES = 3
  - CHALLENGES_Q = 96
  - MAX_PARTREC_SIZE = 600,000 bytes
- α‑II caps (as implemented):
  - MAX_PI_LEN = 1,048,576 (example cap)
  - MAX_ELL_LEN = 65,536 (example cap)
- α‑III fees (as implemented):
  - MIN_TX_UOBX = 10 (μOBX)
  - FLAT_SWITCH_UOBX = 1,000 (μOBX)
  - FLAT_FEE_UOBX = 10 (μOBX)
  - Percent branch = ceil(1%)

Action: Consolidate these into a single module re‑exported by each α‑crate (no code changes are required to adopt this plan; consolidation occurs when we implement).

—

α‑I Participation (VRF + RAM‑Hard + Merkle)
VRF
- Suite: RFC 9381 ECVRF‑EDWARDS25519‑SHA512‑TAI.
- Encodings: pk = 32 bytes, proof π = 80 bytes, output β/y = 64 bytes.
- Alpha derivation (exact as code):
  - alpha32 = H("obex.alpha", [ parent_id(32), LE(slot,8), y_edge_prev(32), vrf_pk(32) ]).
- Verifier adapter: returns Option<[u8;64]>; reject on any parse/verification failure.

Seed and Labeling
- seed = H("obex.seed", [ y_edge_prev(32), pk_ed25519(32), vrf_y(64) ]).
- Label update (per pass):
  - lbl_i = H("obex.lbl", [ seed(32), LE(i,8), l_{i-1}(32), l_j(32), l_k(32) ]).
- Index derivations (deterministic within pass):
  - j = idx_j(seed, i, pass) via H("obex.idx", [ seed, LE(i,8), LE(pass,4), [0x00] ]).
  - k = idx_k(seed, i, pass) via H("obex.idx", [ seed, LE(i,8), LE(pass,4), [0x01] ]).
  - Challenge index per t: i_t = 1 + (LE64(H("obex.chal", [ y_edge_prev, root, vrf_y, LE(t,4) ])[..8]) mod (N_LABELS − 1)).

Merkle
- Binary tree, duplicate‑last when odd; empty root = H("obex.merkle.empty", []).
- Leaf hash = H("obex.merkle.leaf", [ label ]) (label is 32 bytes).
- Node hash = H("obex.merkle.node", [ left(32) || right(32) ]).
- Verification walks siblings from leaf up; constant‑time equality for roots.

Participation Record (ObexPartRec)
- Fields (current canonical codec; sizes are exact, LE for integers):
  - version: u32 LE (= OBEX_ALPHA_I_VERSION)
  - slot: u64 LE
  - pk_ed25519: [u8;32]
  - vrf_pk: [u8;32]
  - y_edge_prev: [u8;32]
  - alpha: [u8;32]
  - vrf_y: [u8;64]
  - vrf_pi: [u8;80]
  - seed: [u8;32]
  - root: [u8;32]
  - challenges: u32 LE count (= 96), then 96 × ChallengeOpen
  - sig: [u8;64] (Ed25519 over transcript H("obex.partrec", [...]))
- ChallengeOpen (current layout):
  - idx: u64 LE
  - li: [u8;32], pi_siblings: u32 LE len + siblings×32
  - lim1: [u8;32], pim1_siblings: u32 LE len + siblings×32
  - lj: [u8;32], pj_siblings: u32 LE len + siblings×32
  - lk: [u8;32], pk_siblings: u32 LE len + siblings×32
- DoS cap: total bytes ≤ 600,000. Enforce before decode/crypto.

Verification (exact equalities)
1) Version/slot/challenges count match.
2) alpha == H("obex.alpha", ...).
3) VRF verifies and vrf_y matches consensus form.
4) seed == H("obex.seed", ...).
5) Ed25519 signature over transcript is valid (verify_strict).
6) For each challenge: indices in range; Merkle verifications for i, i−1, j, k succeed; label equation holds.

Participation Root P_s
- Build from unique ed25519 pk set for slot s; sort ascending; leaves = H("obex.part.leaf", []) || pk; root = Merkle(leaves).

—

α‑II Header (Deterministic Equalities + VDF Adapter)
Canonical header struct (as implemented)
- parent_id: [u8;32]
- slot: u64 LE
- obex_version: u32 LE (= OBEX_ALPHA_II_VERSION)
- seed_commit: [u8;32] where seed_commit == H("obex.slot.seed", [ parent_id, LE(slot,8) ])
- vdf_y_core: [u8;32] (placeholder size; final size depends on VDF backend)
- vdf_y_edge: [u8;32]
- vdf_pi: Vec<u8> with u32 LE length
- vdf_ell: Vec<u8> with u32 LE length
- ticket_root: [u8;32]
- part_root: [u8;32]
- txroot_prev: [u8;32]

Header ID (current)
- obex_header_id(h) = H("obex.header.id", [ field‑wise values with explicit lengths ])

Validation (must all hold)
1) Parent link: h.parent_id == obex_header_id(parent).
2) Slot: h.slot == parent.slot + 1.
3) Version: h.obex_version == OBEX_ALPHA_II_VERSION.
4) Size caps: |vdf_pi| ≤ MAX_PI_LEN; |vdf_ell| ≤ MAX_ELL_LEN.
5) seed_commit equality: computed from (parent_id, slot) as above.
6) Beacon verification (adapter): verify(inputs) == true.
7) ticket_root equality: equals locally recomputed ticket_root for slot s.
8) part_root equality: equals locally recomputed part_root for slot s.
9) txroot_prev equality: equals local txroot for slot s−1.

—

 Beacon v1 (Hash‑Edge) — Frozen for Testnet
 Goal: Use a zero‑overhead beacon adapter for testnet: y_edge = H("obex.vdf.edge", [ y_core ]), with empty pi/ell.

 Transcript and Encodings (normative for testnet)
 - y_core: 32 bytes (Hash256) supplied by beacon provider.
 - y_edge: 32 bytes where y_edge == H("obex.vdf.edge", [ y_core ]).
 - pi: empty (0 bytes). ell: empty (0 bytes).

Time Parameter T (calibration)
- Provide a small CLI (obex‑vdf‑cal) to measure a reference machine; set T conservatively; commit value and vectors.

 Verifier contract (single function)
 ```
 bool beacon_v1_verify(
   y_core: &[u8;32],
   y_edge: &[u8;32],
   pi: &[u8],  // MUST be empty
   ell: &[u8], // MUST be empty
 )
 ```
 - Steps: (1) assert pi.len()==0 and ell.len()==0; (2) check y_edge == H("obex.vdf.edge", [ y_core ]).

 Golden vectors (Beacon v1)
 - Files: seed_commit.bin (32), y_core.bin (32), y_edge.bin (32), pi.bin (0), ell.bin (0), plus negatives (y_edge mismatch; non‑empty pi/ell).

—

α‑III Admission (Tx Canonical Bytes, Fees, Tickets, Root)
Tx Body V1 (as implemented)
- Canonical bytes = H("obex.tx.body.v1", []) || sender(32) || recipient(32) || LE(nonce,8) || LE(amount_u,16) || LE(fee_u,16) || LE(s_bind,8) || y_bind(32) || encode_access(access) || LE(memo_len,4) || memo.
- TxID = H("obex.tx.id", [ canonical_tx_bytes ]).
- TxCommit = H("obex.tx.commit", [ canonical_tx_bytes ]).
- Signature message = H("obex.tx.sig", [ canonical_tx_bytes ]); verify_strict.

Fee Rule (as implemented)
- If amount_u ≤ 1,000 → fee = 10; else fee = ceil(amount_u / 100). All integers are u128; avoid overflow by saturating ops where relevant.

TicketRecord (as implemented)
- Fields: ticket_id(32), txid(32), sender(32), nonce(u64 LE), amount_u(u128 LE), fee_u(u128 LE), s_admit(u64 LE), s_exec(u64 LE), commit_hash(32).
- Leaf encoding: H("obex.ticket.leaf", []) || all fields in canonical order; ticket_root = Merkle over encoded leaves, sorted by txid.

Admission Process
1) Verify signature, slot binding (s_bind == s_now), beacon binding (y_bind == y_prev), nonce match, min amount, fee rule, and sufficient funds.
2) Update state maps: spendable, reserved, next_nonce, admitted_by_slot, tickets_by_txid.
3) Build per‑slot ticket_root deterministically.

—

α‑T Tokenomics (Emission, NLB Fee Splits, DRP, SysTx Order)
Emission
- Accumulator method with halving; terminal slot residual flush to guarantee total supply reached exactly.
- Constants and arithmetic match current α‑T implementation (U256 accumulators where needed).

Fee Splits (NLB)
- Epoch snapshots keyed by slot/epoch length; fee escrow accounting; release proportional splits subject to escrow cap; burn accounted into effective supply.

DRP Distribution
- Baseline + lottery K winners, unique indices derived from beacon; reward_rank ordering for deterministic payout ordering; burn remainders.

System Tx Canonical Order
- Order: ESCROW_CREDIT → EMISSION_CREDIT → VERIFIER_CREDIT → TREASURY_CREDIT → BURN → REWARD_PAYOUT (reward payouts sorted by reward_rank).

—

Networking & Availability Policy (Header‑First + Fetch)
Principles
- Header‑first validation; fetch bodies/proofs on demand to recompute roots locally; do not trust remote roots.

Endpoints (minimum viable)
- GET /alpha_i/{slot}/{pk} → canonical `ObexPartRec` bytes (enforce ≤ MAX_PARTREC_SIZE). One per pk per peer per slot.
- GET /alpha_iii/{slot} → concatenated canonical `TicketRecord` bytes for slot s.
- Optional: GET /tx/{id} → canonical tx bytes used in admission for audit.

DoS Controls
- Rate‑limit re‑requests; cap outstanding fetches per slot; enforce size caps before decode.

—

Golden Vectors (Format and Coverage)
Directory: tests/golden/
- vdf/: delta_bits.hex, g.bin, T.bin (LE8), seed_commit.bin, y_core.bin, y_edge.bin, ell.bin, pi.bin, negatives/*.
- alpha_i/: pk.bin, vrf_output.bin, vrf_proof.bin, root.bin, partrec.bin, P_s.root.bin, negatives/*.
- alpha_iii/: ticket_leaves.bin (concat), ticket_root.bin, fee_edges.json, negatives/*.
- header/: header.bin (serialized), header_id.bin, negatives/*.

Rules
- All goldens are exact; tests recompute and assert byte‑for‑byte equality; negatives must fail.

—

Testing Strategy (Unit, Fuzz, E2E, Golden, Perf Gates)
Unit tests
- Cover hashing/tagging, Merkle edge cases (empty, duplicate‑last), α‑I indices/label equations, α‑III fee edges, α‑T arithmetic invariants, header build/validate round‑trip.

Fuzzing (nightly/manual)
- Decode paths: partrec, header, tx; Merkle verification; VDF transcript parse. Reject oversize early; must not panic.

E2E 3‑slot Pipeline
- Parent slot s−1: fixed txroot_{s−1} from golden.
- Slot s: build P_s from fixed partrecs; build tickets from fixed tx set; compute roots; construct header; validate.
- Slot s+1: repeat with different seeds; assert single valid header per (parent,s).

Performance Gates (reference box)
- vdf_verify ≤ 10 ms
- α‑I verify (Q=96) ≤ 60–70 ms
- ticket_root build ≤ 20 ms
- header_validate (end‑to‑end) ≤ 100 ms
- Hard floor for low‑end CPUs ≤ 2× reference (documented separately)

—

Observability (Metrics, Logs, Reject Codes)
Metrics (OpenMetrics)
- headers_validated_total, headers_rejected_total{reason}
- vdf_verify_ms_histogram, alpha_i_verify_ms_histogram, ticket_root_ms_histogram
- fetch_failures_total{endpoint,reason}

Logs (structured JSON)
- INFO default; include header_id, slot, parent_id, and reject reason code.

Reject Codes (stable enums)
- HeaderReject: VersionMismatch, BadParentLink, BadSlot, VdfPiTooBig, VdfEllTooBig, BadSeedCommit, BeaconInvalid, TicketRootMismatch, PartRootMismatch, TxRootPrevMismatch.
- AlphaIReject: VersionMismatch, SlotMismatch, ChallengesLen, AlphaMismatch, VrfVerifyFailed, VrfOutputMismatch, SeedMismatch, SigInvalid, ChalIndexMismatch, ChalIndexBounds, JOrKOutOfRange, MerkleLiInvalid, MerkleLim1Invalid, MerkleLjInvalid, MerkleLkInvalid, LabelEquationMismatch, Oversize.

—

Genesis & Packaging (Configs, Binaries, Devnet → Public Testnet)
Genesis (TOML)
- network_id, genesis_header_id, OBEX_ALPHA_*_VERSION, VDF params (Δ bits, g.bin base64, T LE8), fee constants.

Node binary (obex‑node)
- Header‑first validator with minimal HTTP server for fetch endpoints; persistent store for headers and slot artifacts; slot scheduler.

Tooling (obex‑tool)
- Encode/decode inspectors; golden generator; vector verifier; KAT dump.

Devnet → Public testnet
- Spin 5 nodes (3 ref hardware, 2 low‑end); run 10k slots with zero divergence; publish peers/telemetry.

—

Solo Developer Workflow (No CI)
Run before tagging or regenerating goldens (PowerShell example):
```
cargo fmt --all; \
cargo clippy --all-targets --all-features -D warnings; \
cargo build --locked; \
cargo test --workspace --all-features; \
cargo test -p e2e -- --ignored golden
```
Optional nightly fuzz:
```
cargo fuzz run registration_decode -- -runs=100000
cargo fuzz run registration_verify -- -runs=100000
```

—

Execution Roadmap (Tasks and Milestones)
Milestone 1 — Consensus Freeze & Spec Alignment
- Consolidate constants/tags into a single module; update docs to match code (LE encodings, tag strings, versions).
- Audit for any stray non‑`obex.*` tags and correct.

Milestone 2 — VDF Backend Freeze
- Implement verifier adapter (Wesolowski) with fixed sizes and transcript; calibrate T on reference box; commit vectors and parameters.

Milestone 3 — Golden Vectors & E2E Pipeline
- Generate full golden set (α‑I, α‑III, header, VDF); implement 3‑slot pipeline test; negative vectors.

Milestone 4 — Node + Networking
- Implement `obex‑node` with header‑first flow, fetch endpoints, storage, scheduler, metrics/logs.

Milestone 5 — Performance & Burn‑In
- Add benches with gates; run 10k‑slot burn‑in on 5‑node devnet; resolve regressions.

Milestone 6 — Public Testnet Packaging
- Produce static binaries (x86_64, aarch64) + SHA256; publish `genesis.toml`, peers; open telemetry dashboard; tag release.

—

Appendix A — Tag Registry (must match code)
- obex.merkle.leaf
- obex.merkle.node
- obex.merkle.empty
- obex.alpha
- obex.part.leaf
- obex.partrec
- obex.seed
- obex.l0
- obex.lbl
- obex.idx
- obex.chal
- obex.vrfy
- obex.header.id
- obex.slot.seed
- obex.vdf.ycore
- obex.vdf.edge
- obex.tx.access
- obex.tx.body.v1
- obex.tx.id
- obex.tx.commit
- obex.tx.sig
- obex.txid.leaf
- obex.ticket.id
- obex.ticket.leaf
- obex.sys.tx
- obex.reward.draw
- obex.reward.rank

Appendix B — Sizes and Encodings (selected)
- Hash256 = [u8;32] (SHA3‑256).
- Integers on wire: little‑endian; widths per field (u32/u64/u128); variable byte vectors prefixed by u32 LE length.
- VRF: pk 32, π 80, y 64.
- α‑I DoS cap: partrec bytes ≤ 600,000.
- α‑II caps: |pi| ≤ 1,048,576; |ell| ≤ 65,536 (until VDF sizes frozen).
- Ticket leaf: domain tag (32) + concatenated fields per α‑III `enc_ticket_leaf`.

Appendix C — Example Equality Checks (pseudocode)
```
assert h.parent_id == obex_header_id(parent)
assert h.slot == parent.slot + 1
assert h.obex_version == OBEX_ALPHA_II_VERSION
assert len(h.vdf_pi) <= MAX_PI_LEN
assert len(h.vdf_ell) <= MAX_ELL_LEN
assert h.seed_commit == H("obex.slot.seed", [h.parent_id, LE(h.slot,8)])
assert beacon.verify(h) == true
assert h.ticket_root == provider.ticket_root(h.slot)
assert h.part_root == provider.part_root(h.slot)
assert h.txroot_prev == provider.txroot(parent.slot)
```

—

Notes
- This plan intentionally mirrors the current α‑crates’ behavior to minimize risk and time‑to‑testnet. Where prior documents differ (endianness, header ID definition, path lengths), the code is treated as normative for testnet. Any deliberate change must regenerate goldens and bump the corresponding α‑version.



'PROJECT_ROOT'>SECURITY_THREAT_MODEL.md
Security Threat Model

Assets
- Consensus rules (hashing, tags, encodings), headers, participation records, ticket records, system txs.

Adversaries
- Byzantine peers (invalid headers/bodies), DoSers (oversize, floods), forgers (invalid VRF/signatures), replayers.

Threats & Mitigations
- Oversize bodies → Pre-crypto size caps (α‑I, VDF buffers, header size).
- Invalid encodings → Canonical codecs; exact length checks; reject trailing bytes.
- Forged VRF/signatures → RFC 9381 ECVRF verify; Ed25519 verify_strict; constant-time compares.
- Header forks → Deterministic equalities; exactly one valid header per (parent, slot).
- Replay/missing data → Header-first; fetch and recompute locally; reject unverifiable.
- Resource exhaustion → Rate limits; per-slot fetch caps; backoff; bounded caches; sorted deterministic builders.

Operational
- Logs omit secrets; structured JSON with reason codes; metrics expose rates not payloads.

Disclosure
- Security contact and responsible disclosure policy published in README.



'PROJECT_ROOT'>SPEC_INDEX.md
OBEX Alpha — Spec Index (Public Testnet Rebuild)

Use this index to navigate the complete, byte-precise specs and rebuild plan. The original folder `OBEX.ALPHA v1 - BACKUP LATEST 30092025 2134/` is frozen and serves as the authoritative reference implementation. These documents do not modify it; they provide a faithful, implementation-ready blueprint to rebuild from scratch without drift.

Core
- CONSENSUS_SPEC.md — Hashing, tags, endianness, Merkle rules, versions, DoS bounds
- ALPHA_I_SPEC.md — Participation (VRF, seed/labels, challenges, ObexPartRec, P_s root)
- ALPHA_II_AND_VDF_SPEC.md — Header spec and VDF freeze plan (Wesolowski)
- ALPHA_III_SPEC.md — Admission (canonical tx bytes, fees, TicketRecord, root)
- ALPHA_T_SPEC.md — Tokenomics (emission, NLB fee splits, DRP, system tx order)

System & Testing
- NETWORKING_AND_AVAILABILITY.md — Header-first flow, endpoints, limits
- GOLDENS_AND_TESTING.md — Golden artifacts, unit/fuzz/e2e, rules
- BYTE_LAYOUTS.md — Exact byte layouts with offsets for all consensus objects
- GOLDEN_MANIFEST.md — Files, lengths, and checksums for goldens
- CONFORMANCE_MATRIX.md — Mapping of spec requirements to code functions

Node & Ops
- NODE_AND_GENESIS.md — Node responsibilities, storage, scheduler, genesis
- API_ENDPOINTS.md — HTTP API request/response shapes and status codes
- ERRORS_AND_CODES.md — Stable reject enums and numeric codes
- PERF_GATES.md — Bench targets, hardware profiles, acceptance gates
- SECURITY_THREAT_MODEL.md — Threats, mitigations, invariants
- OPS_SECURITY_PERF_BUILD.md — Ops posture and local build workflow (no CI)

Plan
- PUBLIC_TESTNET_PLAN.md — End-to-end execution plan and milestones
- IMPLEMENTATION_CHECKLIST.md — Concrete task list to rebuild without drift

Note on Tag Names
- All consensus hashes must use tags in the `obex.*` namespace as listed in CONSENSUS_SPEC.md and SPEC_FREEZE.md. During rebuild, audit that helper functions do not use un-namespaced variants.



'PROJECT_ROOT'>obex-alpha>Cargo.lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "addr2line"
version = "0.25.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b5d307320b3181d6d7954e663bd7c774a838b8220fe0593c86d9fb09f498b4b"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "anes"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b46cbb362ab8752921c97e041f5e366ee6297bd428a31275b9fcf1e380f7299"

[[package]]
name = "anstream"
version = "0.6.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43d5b281e737544384e969a5ccad3f1cdd24b48086a0fc1b2a5262a26b8f4f4a"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5192cca8006f1fd4f7237516f40fa183bb07f8fbdfedaa0036de5ea9b0b45e78"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e231f6134f61b71076a3eab506c379d4f36122f2af15a9ff04415ea4c3339e2"
dependencies = [
 "windows-sys 0.60.2",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3e0633414522a32ffaac8ac6cc8f748e090c5717661fddeea04219e2344f5f2a"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.60.2",
]

[[package]]
name = "anyhow"
version = "1.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a23eb6b1614318a8071c9b2521f36b424b2c83db5eb3a0fead4a6c0809af6e61"

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "async-trait"
version = "0.1.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9035ad2d096bed7955a320ee7e2230574d28fd3c3a0f186cbea1ff3c7eed5dbb"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "axum"
version = "0.7.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edca88bc138befd0323b20752846e6587272d3b03b0343c8ea28a6f819e6e71f"
dependencies = [
 "async-trait",
 "axum-core",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "http-body-util",
 "hyper",
 "hyper-util",
 "itoa",
 "matchit",
 "memchr",
 "mime",
 "percent-encoding",
 "pin-project-lite",
 "rustversion",
 "serde",
 "serde_json",
 "serde_path_to_error",
 "serde_urlencoded",
 "sync_wrapper",
 "tokio",
 "tower",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "axum-core"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09f2bd6146b97ae3359fa0cc6d6b376d9539582c7b4220f041a33ec24c226199"
dependencies = [
 "async-trait",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "http-body-util",
 "mime",
 "pin-project-lite",
 "rustversion",
 "sync_wrapper",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "backtrace"
version = "0.3.76"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb531853791a215d7c62a30daf0dde835f381ab5de4589cfe7c649d2cbe92bd6"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-link 0.2.0",
]

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "bit-set"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08807e080ed7f9d5433fa9b275196cfc35414f66a0c79d864dc51a0d825231a3"
dependencies = [
 "bit-vec",
]

[[package]]
name = "bit-vec"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e764a1d40d510daf35e07be9eb06e75770908c27d411ee6c92109c9840eaaf7"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"

[[package]]
name = "bitvec"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c"
dependencies = [
 "funty",
 "radium",
 "tap",
 "wyz",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"

[[package]]
name = "byte-slice-cast"
version = "1.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7575182f7272186991736b70173b0ea045398f984bf5ebbb3804736ce1330c9d"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"

[[package]]
name = "cast"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37b2a672a2cb129a2e41c10b1224bb368f9f37a2b16b612598138befd7b37eb5"

[[package]]
name = "cc"
version = "1.2.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1d05d92f4b1fd76aad469d46cdd858ca761576082cd37df81416691e50199fb"
dependencies = [
 "find-msvc-tools",
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fd1289c04a9ea8cb22300a459a72a385d7c73d3259e2ed7dcb2af674838cfa9"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "ciborium"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42e69ffd6f0917f5c029256a24d0161db17cea3997d185db0d35926308770f0e"
dependencies = [
 "ciborium-io",
 "ciborium-ll",
 "serde",
]

[[package]]
name = "ciborium-io"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05afea1e0a06c9be33d539b876f1ce3692f4afea2cb41f740e7743225ed1c757"

[[package]]
name = "ciborium-ll"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57663b653d948a338bfb3eeba9bb2fd5fcfaecb9e199e87e1eda4d9e8b240fd9"
dependencies = [
 "ciborium-io",
 "half",
]

[[package]]
name = "clap"
version = "4.5.48"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2134bb3ea021b78629caa971416385309e0131b351b25e01dc16fb54e1b5fae"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.48"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2ba64afa3c0a6df7fa517765e31314e983f51dda798ffba27b988194fb65dc9"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.47"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbfd7eae0b0f1a6e63d4b13c9c478de77c2eb546fba158ad50b4203dc24b9f9c"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b94f61472cee1439c0b966b47e3aca9ae07e45d070759512cd390ea2bebc6675"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "const-oid"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"

[[package]]
name = "const_format"
version = "0.2.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "126f97965c8ad46d6d9163268ff28432e8f6a1196a55578867832e3049df63dd"
dependencies = [
 "const_format_proc_macros",
]

[[package]]
name = "const_format_proc_macros"
version = "0.2.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d57c2eccfb16dbac1f4e61e206105db5820c9d26c3c472bc17c774259ef7744"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-xid",
]

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
dependencies = [
 "cfg-if",
]

[[package]]
name = "criterion"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2b12d017a929603d80db1831cd3a24082f8137ce19c69e6447f54f5fc8d692f"
dependencies = [
 "anes",
 "cast",
 "ciborium",
 "clap",
 "criterion-plot",
 "is-terminal",
 "itertools",
 "num-traits",
 "once_cell",
 "oorandom",
 "plotters",
 "rayon",
 "regex",
 "serde",
 "serde_derive",
 "serde_json",
 "tinytemplate",
 "walkdir",
]

[[package]]
name = "criterion-plot"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b50826342786a51a89e2da3a28f1c32b06e387201bc2d19791f622c673706b1"
dependencies = [
 "cast",
 "itertools",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "crunchy"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "460fbee9c2c2f33933d720630a6a0bac33ba7053db5344fac858d4b8952d77d5"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "curve25519-dalek"
version = "4.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97fb8b7c4503de7d6ae7b42ab72a5a59857b4c937ec27a3d4539dba95b5ab2be"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "curve25519-dalek-derive",
 "digest",
 "fiat-crypto",
 "rustc_version",
 "subtle",
]

[[package]]
name = "curve25519-dalek-derive"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f46882e17999c6cc590af592290432be3bce0428cb0d5f8b6715e4dc7b383eb3"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "der"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7c1832837b905bbfb5101e07cc24c8deddf52f93225eee6ead5f4d63d53ddcb"
dependencies = [
 "const-oid",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "displaydoc"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "ed25519"
version = "2.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "115531babc129696a58c64a4fef0a8bf9e9698629fb97e9e40767d235cfbcd53"
dependencies = [
 "pkcs8",
 "signature",
]

[[package]]
name = "ed25519-dalek"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70e796c081cee67dc755e1a36a0a172b897fab85fc3f6bc48307991f64e4eca9"
dependencies = [
 "curve25519-dalek",
 "ed25519",
 "sha2",
 "subtle",
]

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "encoding_rs"
version = "0.8.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "errno"
version = "0.3.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39cab71617ae0d63f51a36d69f866391735b51691dbda63cf6f96d042b63efeb"
dependencies = [
 "libc",
 "windows-sys 0.61.1",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "ff"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0b50bfb653653f9ca9095b427bed08ab8d75a137839d9ad64eb11810d5b6393"
dependencies = [
 "rand_core 0.6.4",
 "subtle",
]

[[package]]
name = "fiat-crypto"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28dea519a9695b9977216879a3ebfddf92f1c08c05d984f8996aecd6ecdc811d"

[[package]]
name = "find-msvc-tools"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0399f9d26e5191ce32c498bebd31e7a3ceabc2745f0ac54af3f335126c3f24b3"

[[package]]
name = "fixed-hash"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "835c052cb0c08c1acf6ffd71c022172e18723949c8282f2b9f27efbc51e64534"
dependencies = [
 "byteorder",
 "rand 0.8.5",
 "rustc-hex",
 "static_assertions",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "form_urlencoded"
version = "1.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb4cb245038516f5f85277875cdaa4f7d2c9a0fa0468de06ed190163b1581fcf"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "fs2"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9564fc758e15025b46aa6643b1b77d047d1a56a1aea6e01002ac0c7026876213"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "funty"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c"

[[package]]
name = "futures"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "fxhash"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c31b6d751ae2c7f11320402d34e41349dd1016f8d5d45e48c4312bc8625af50c"
dependencies = [
 "byteorder",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "wasm-bindgen",
]

[[package]]
name = "getrandom"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "r-efi",
 "wasi 0.14.7+wasi-0.2.4",
 "wasm-bindgen",
]

[[package]]
name = "gimli"
version = "0.32.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e629b9b98ef3dd8afe6ca2bd0f89306cec16d43d907889945bc5d6687f2f13c7"

[[package]]
name = "group"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0f9ef7462f7c099f518d754361858f86d8a07af53ba9af0fe635bbccb151a63"
dependencies = [
 "ff",
 "rand_core 0.6.4",
 "subtle",
]

[[package]]
name = "h2"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3c0b69cfcb4e1b9f1bf2f53f95f766e4661169728ec61cd3fe5a0166f2d1386"
dependencies = [
 "atomic-waker",
 "bytes",
 "fnv",
 "futures-core",
 "futures-sink",
 "http",
 "indexmap",
 "slab",
 "tokio",
 "tokio-util",
 "tracing",
]

[[package]]
name = "half"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "459196ed295495a68f7d7fe1d84f6c4b7ff0e21fe3017b2f283c6fac3ad803c9"
dependencies = [
 "cfg-if",
 "crunchy",
]

[[package]]
name = "hashbrown"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5419bdc4f6a9207fbeba6d11b604d481addf78ecd10c11ad51e76c2f6482748d"

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc0fef456e4baa96da950455cd02c081ca953b141298e41db3fc7e36b1da849c"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "http"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4a85d31aea989eead29a3aaf9e1115a180df8282431156e533de47660892565"
dependencies = [
 "bytes",
 "fnv",
 "itoa",
]

[[package]]
name = "http-body"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
dependencies = [
 "bytes",
 "http",
]

[[package]]
name = "http-body-util"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b021d93e26becf5dc7e1b75b1bed1fd93124b374ceb73f43d4d4eafec896a64a"
dependencies = [
 "bytes",
 "futures-core",
 "http",
 "http-body",
 "pin-project-lite",
]

[[package]]
name = "httparse"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6dbf3de79e51f3d586ab4cb9d5c3e2c14aa28ed23d180cf89b4df0454a69cc87"

[[package]]
name = "httpdate"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"

[[package]]
name = "hyper"
version = "1.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb3aa54a13a0dfe7fbe3a59e0c76093041720fdc77b110cc0fc260fafb4dc51e"
dependencies = [
 "atomic-waker",
 "bytes",
 "futures-channel",
 "futures-core",
 "h2",
 "http",
 "http-body",
 "httparse",
 "httpdate",
 "itoa",
 "pin-project-lite",
 "pin-utils",
 "smallvec",
 "tokio",
 "want",
]

[[package]]
name = "hyper-rustls"
version = "0.27.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3c93eb611681b207e1fe55d5a71ecf91572ec8a6705cdb6857f7d8d5242cf58"
dependencies = [
 "http",
 "hyper",
 "hyper-util",
 "rustls",
 "rustls-pki-types",
 "tokio",
 "tokio-rustls",
 "tower-service",
 "webpki-roots",
]

[[package]]
name = "hyper-tls"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70206fc6890eaca9fde8a0bf71caa2ddfc9fe045ac9e5c70df101a7dbde866e0"
dependencies = [
 "bytes",
 "http-body-util",
 "hyper",
 "hyper-util",
 "native-tls",
 "tokio",
 "tokio-native-tls",
 "tower-service",
]

[[package]]
name = "hyper-util"
version = "0.1.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c6995591a8f1380fcb4ba966a252a4b29188d51d2b89e3a252f5305be65aea8"
dependencies = [
 "base64",
 "bytes",
 "futures-channel",
 "futures-core",
 "futures-util",
 "http",
 "http-body",
 "hyper",
 "ipnet",
 "libc",
 "percent-encoding",
 "pin-project-lite",
 "socket2 0.6.0",
 "system-configuration",
 "tokio",
 "tower-service",
 "tracing",
 "windows-registry",
]

[[package]]
name = "icu_collections"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
dependencies = [
 "displaydoc",
 "potential_utf",
 "yoke",
 "zerofrom",
 "zerovec",
]

[[package]]
name = "icu_locale_core"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
dependencies = [
 "displaydoc",
 "litemap",
 "tinystr",
 "writeable",
 "zerovec",
]

[[package]]
name = "icu_normalizer"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_normalizer_data",
 "icu_properties",
 "icu_provider",
 "smallvec",
 "zerovec",
]

[[package]]
name = "icu_normalizer_data"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"

[[package]]
name = "icu_properties"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_locale_core",
 "icu_properties_data",
 "icu_provider",
 "potential_utf",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "icu_properties_data"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"

[[package]]
name = "icu_provider"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
dependencies = [
 "displaydoc",
 "icu_locale_core",
 "stable_deref_trait",
 "tinystr",
 "writeable",
 "yoke",
 "zerofrom",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "idna"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b0875f23caa03898994f6ddc501886a45c7d3d62d04d2d90788d47be1b1e4de"
dependencies = [
 "idna_adapter",
 "smallvec",
 "utf8_iter",
]

[[package]]
name = "idna_adapter"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
dependencies = [
 "icu_normalizer",
 "icu_properties",
]

[[package]]
name = "impl-codec"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba6a270039626615617f3f36d15fc827041df3b78c439da2cadfa47455a77f2f"
dependencies = [
 "parity-scale-codec",
]

[[package]]
name = "impl-trait-for-tuples"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a0eb5a3343abf848c0984fe4604b2b105da9539376e24fc0a3b0007411ae4fd9"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "indexmap"
version = "2.11.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b0f83760fb341a774ed326568e19f5a863af4a952def8c39f9ab92fd95b88e5"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "instant"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222"
dependencies = [
 "cfg-if",
]

[[package]]
name = "io-uring"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "046fa2d4d00aea763528b4950358d0ead425372445dc8ff86312b3c69ff7727b"
dependencies = [
 "bitflags 2.9.4",
 "cfg-if",
 "libc",
]

[[package]]
name = "ipnet"
version = "2.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "469fb0b9cefa57e3ef31275ee7cacb78f2fdca44e4765491884a2b119d4eb130"

[[package]]
name = "iri-string"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbc5ebe9c3a1a7a5127f920a418f7585e9e758e911d0466ed004f393b0e380b2"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "is-terminal"
version = "0.4.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e04d7f318608d35d4b61ddd75cbdaee86b023ebe2bd5a66ee0915f0bf93095a9"
dependencies = [
 "hermit-abi",
 "libc",
 "windows-sys 0.59.0",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "js-sys"
version = "0.3.81"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec48937a97411dcb524a265206ccd4c90bb711fca92b2792c407f268825b9305"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "keccak"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecc2af9a1119c51f12a14607e783cb977bde58bc069ff0c3da1095e635d70654"
dependencies = [
 "cpufeatures",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.176"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "58f929b4d672ea937a23a1ab494143d968337a5f47e56d0815df1e0890ddf174"

[[package]]
name = "linux-raw-sys"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df1d3c3b53da64cf5760482273a98e575c651a67eec7f77df96b5b642de8f039"

[[package]]
name = "litemap"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"

[[package]]
name = "lock_api"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34080505efa8e45a4b816c349525ebe327ceaa8559756f0356cba97ef3bf7432"

[[package]]
name = "lru-slab"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "112b39cec0b298b6c1999fee3e31427f74f676e4cb9879ed1a121b43661a4154"

[[package]]
name = "matchit"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e7465ac9959cc2b1404e8e2367b43684a6d13790fe23056cc8c6c5a6b7bcb94"

[[package]]
name = "memchr"
version = "2.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f52b00d39961fc5b2736ea853c9cc86238e165017a493d1d5c8eac6bdc4cc273"

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
]

[[package]]
name = "mio"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
dependencies = [
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "windows-sys 0.59.0",
]

[[package]]
name = "native-tls"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87de3442987e9dbec73158d5c715e7ad9072fda936bb03d19d7fa10e00520f0e"
dependencies = [
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "obex_alpha_i"
version = "1.0.0"
dependencies = [
 "criterion",
 "ed25519-dalek",
 "obex_primitives",
 "proptest",
 "thiserror 1.0.69",
]

[[package]]
name = "obex_alpha_ii"
version = "1.0.0"
dependencies = [
 "criterion",
 "obex_primitives",
 "proptest",
 "thiserror 1.0.69",
]

[[package]]
name = "obex_alpha_iii"
version = "1.0.0"
dependencies = [
 "ed25519-dalek",
 "obex_primitives",
]

[[package]]
name = "obex_alpha_t"
version = "1.0.0"
dependencies = [
 "obex_primitives",
 "primitive-types",
 "thiserror 1.0.69",
]

[[package]]
name = "obex_e2e"
version = "1.0.0"
dependencies = [
 "hex",
 "obex_alpha_i",
 "obex_alpha_ii",
 "obex_alpha_iii",
 "obex_alpha_t",
 "obex_primitives",
]

[[package]]
name = "obex_node"
version = "1.0.0"
dependencies = [
 "anyhow",
 "axum",
 "clap",
 "futures",
 "hex",
 "obex_alpha_i",
 "obex_alpha_ii",
 "obex_alpha_iii",
 "obex_alpha_t",
 "obex_primitives",
 "reqwest",
 "serde",
 "serde_json",
 "sha2",
 "sled",
 "subtle",
 "thiserror 1.0.69",
 "tokio",
 "toml",
 "vrf-rfc9381",
]

[[package]]
name = "obex_primitives"
version = "1.0.0"
dependencies = [
 "sha3",
 "subtle",
 "thiserror 1.0.69",
]

[[package]]
name = "obex_tool"
version = "1.0.0"
dependencies = [
 "clap",
 "hex",
 "obex_alpha_i",
 "obex_alpha_ii",
 "obex_alpha_iii",
 "obex_primitives",
 "reqwest",
 "serde",
 "serde_json",
]

[[package]]
name = "object"
version = "0.37.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff76201f031d8863c38aa7f905eca4f53abbfa15f609db4277d44cd8938f33fe"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4895175b425cb1f87721b59f0f286c2092bd4af812243672510e1ac53e2e0ad"

[[package]]
name = "oorandom"
version = "11.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6790f58c7ff633d8771f42965289203411a5e5c68388703c06e14f24770b41e"

[[package]]
name = "openssl"
version = "0.10.73"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8505734d46c8ab1e19a1dce3aef597ad87dcb4c37e7188231769bd6bd51cebf8"
dependencies = [
 "bitflags 2.9.4",
 "cfg-if",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-macros",
 "openssl-sys",
]

[[package]]
name = "openssl-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "openssl-probe"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d05e27ee213611ffe7d6348b942e8f942b37114c00cc03cec254295a4a17852e"

[[package]]
name = "openssl-sys"
version = "0.9.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90096e2e47630d78b7d1c20952dc621f957103f8bc2c8359ec81290d75238571"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "parity-scale-codec"
version = "3.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "799781ae679d79a948e13d4824a40970bfa500058d245760dd857301059810fa"
dependencies = [
 "arrayvec",
 "bitvec",
 "byte-slice-cast",
 "const_format",
 "impl-trait-for-tuples",
 "parity-scale-codec-derive",
 "rustversion",
 "serde",
]

[[package]]
name = "parity-scale-codec-derive"
version = "3.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34b4653168b563151153c9e4c08ebed57fb8262bebfa79711552fa983c623e7a"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "parking_lot"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99"
dependencies = [
 "instant",
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60a2cfe6f0ad2bfc16aefa463b497d5c7a5ecd44a23efa72aa342d90177356dc"
dependencies = [
 "cfg-if",
 "instant",
 "libc",
 "redox_syscall",
 "smallvec",
 "winapi",
]

[[package]]
name = "percent-encoding"
version = "2.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b4f627cb1b25917193a259e49bdad08f671f8d9708acfd5fe0a8c1455d87220"

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkcs8"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "plotters"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5aeb6f403d7a4911efb1e33402027fc44f29b5bf6def3effcc22d7bb75f2b747"
dependencies = [
 "num-traits",
 "plotters-backend",
 "plotters-svg",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "plotters-backend"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df42e13c12958a16b3f7f4386b9ab1f3e7933914ecea48da7139435263a4172a"

[[package]]
name = "plotters-svg"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51bae2ac328883f7acdfea3d66a7c35751187f870bc81f94563733a154d7a670"
dependencies = [
 "plotters-backend",
]

[[package]]
name = "potential_utf"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "84df19adbe5b5a0782edcab45899906947ab039ccf4573713735ee7de1e6b08a"
dependencies = [
 "zerovec",
]

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "primitive-types"
version = "0.12.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b34d9fd68ae0b74a41b21c03c2f62847aa0ffea044eee893b4c140b37e244e2"
dependencies = [
 "fixed-hash",
 "impl-codec",
 "uint",
]

[[package]]
name = "proc-macro-crate"
version = "3.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "219cb19e96be00ab2e37d6e299658a0cfa83e52429179969b0f0121b4ac46983"
dependencies = [
 "toml_edit 0.23.6",
]

[[package]]
name = "proc-macro2"
version = "1.0.101"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89ae43fd86e4158d6db51ad8e2b80f313af9cc74f5c0e03ccb87de09998732de"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "proptest"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bb0be07becd10686a0bb407298fb425360a5c44a663774406340c59a22de4ce"
dependencies = [
 "bit-set",
 "bit-vec",
 "bitflags 2.9.4",
 "lazy_static",
 "num-traits",
 "rand 0.9.2",
 "rand_chacha 0.9.0",
 "rand_xorshift",
 "regex-syntax",
 "rusty-fork",
 "tempfile",
 "unarray",
]

[[package]]
name = "quick-error"
version = "1.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0"

[[package]]
name = "quinn"
version = "0.11.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "626214629cda6781b6dc1d316ba307189c85ba657213ce642d9c77670f8202c8"
dependencies = [
 "bytes",
 "cfg_aliases",
 "pin-project-lite",
 "quinn-proto",
 "quinn-udp",
 "rustc-hash",
 "rustls",
 "socket2 0.5.10",
 "thiserror 2.0.17",
 "tokio",
 "tracing",
 "web-time",
]

[[package]]
name = "quinn-proto"
version = "0.11.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49df843a9161c85bb8aae55f101bc0bac8bcafd637a620d9122fd7e0b2f7422e"
dependencies = [
 "bytes",
 "getrandom 0.3.3",
 "lru-slab",
 "rand 0.9.2",
 "ring",
 "rustc-hash",
 "rustls",
 "rustls-pki-types",
 "slab",
 "thiserror 2.0.17",
 "tinyvec",
 "tracing",
 "web-time",
]

[[package]]
name = "quinn-udp"
version = "0.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcebb1209ee276352ef14ff8732e24cc2b02bbac986cd74a4c81bcb2f9881970"
dependencies = [
 "cfg_aliases",
 "libc",
 "once_cell",
 "socket2 0.5.10",
 "tracing",
 "windows-sys 0.52.0",
]

[[package]]
name = "quote"
version = "1.0.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce25767e7b499d1b604768e7cde645d14cc8584231ea6b295e9c9eb22c02e1d1"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "radium"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc33ff2d4973d518d823d61aa239014831e521c75da58e3df4840d3f47749d09"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha 0.3.1",
 "rand_core 0.6.4",
]

[[package]]
name = "rand"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6db2770f06117d490610c7488547d543617b21bfa07796d7a12f6f1bd53850d1"
dependencies = [
 "rand_chacha 0.9.0",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_chacha"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
dependencies = [
 "ppv-lite86",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.16",
]

[[package]]
name = "rand_core"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
dependencies = [
 "getrandom 0.3.3",
]

[[package]]
name = "rand_xorshift"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "513962919efc330f829edb2535844d1b912b0fbe2ca165d613e4e8788bb05a5a"
dependencies = [
 "rand_core 0.9.3",
]

[[package]]
name = "rayon"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "368f01d005bf8fd9b1206fb6fa653e6c4a81ceb1466406b81792d87c5677a58f"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22e18b0f0062d30d4230b2e85ff77fdfe4326feb054b9783a3460d8435c8ab91"
dependencies = [
 "crossbeam-deque",
 "crossbeam-utils",
]

[[package]]
name = "redox_syscall"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "regex"
version = "1.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b5288124840bee7b386bc413c487869b360b2b4ec421ea56425128692f2a82c"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "833eb9ce86d40ef33cb1306d8accf7bc8ec2bfea4355cbdebb3df68b40925cad"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"

[[package]]
name = "reqwest"
version = "0.12.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d429f34c8092b2d42c7c93cec323bb4adeb7c67698f70839adec842ec10c7ceb"
dependencies = [
 "base64",
 "bytes",
 "encoding_rs",
 "futures-channel",
 "futures-core",
 "futures-util",
 "h2",
 "http",
 "http-body",
 "http-body-util",
 "hyper",
 "hyper-rustls",
 "hyper-tls",
 "hyper-util",
 "js-sys",
 "log",
 "mime",
 "native-tls",
 "percent-encoding",
 "pin-project-lite",
 "quinn",
 "rustls",
 "rustls-pki-types",
 "serde",
 "serde_json",
 "serde_urlencoded",
 "sync_wrapper",
 "tokio",
 "tokio-native-tls",
 "tokio-rustls",
 "tower",
 "tower-http",
 "tower-service",
 "url",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "webpki-roots",
]

[[package]]
name = "ring"
version = "0.17.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7"
dependencies = [
 "cc",
 "cfg-if",
 "getrandom 0.2.16",
 "libc",
 "untrusted",
 "windows-sys 0.52.0",
]

[[package]]
name = "rustc-demangle"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f7d92ca342cea22a06f2121d944b4fd82af56988c270852495420f961d4ace"

[[package]]
name = "rustc-hash"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "357703d41365b4b27c590e3ed91eabb1b663f07c4c084095e60cbed4362dff0d"

[[package]]
name = "rustc-hex"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3e75f6a532d0fd9f7f13144f392b6ad56a32696bfcd9c78f797f16bbb6f072d6"

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver",
]

[[package]]
name = "rustix"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd15f8a2c5551a84d56efdc1cd049089e409ac19a3072d5037a17fd70719ff3e"
dependencies = [
 "bitflags 2.9.4",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.61.1",
]

[[package]]
name = "rustls"
version = "0.23.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd3c25631629d034ce7cd9940adc9d45762d46de2b0f57193c4443b92c6d4d40"
dependencies = [
 "once_cell",
 "ring",
 "rustls-pki-types",
 "rustls-webpki",
 "subtle",
 "zeroize",
]

[[package]]
name = "rustls-pki-types"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "229a4a4c221013e7e1f1a043678c5cc39fe5171437c88fb47151a21e6f5b5c79"
dependencies = [
 "web-time",
 "zeroize",
]

[[package]]
name = "rustls-webpki"
version = "0.103.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e10b3f4191e8a80e6b43eebabfac91e5dcecebb27a71f04e820c47ec41d314bf"
dependencies = [
 "ring",
 "rustls-pki-types",
 "untrusted",
]

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "rusty-fork"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb3dcc6e454c328bb824492db107ab7c0ae8fcffe4ad210136ef014458c1bc4f"
dependencies = [
 "fnv",
 "quick-error",
 "tempfile",
 "wait-timeout",
]

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "schannel"
version = "0.1.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "891d81b926048e76efe18581bf793546b4c0eaf8448d72be8de2bbee5fd166e1"
dependencies = [
 "windows-sys 0.61.1",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "security-framework"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02"
dependencies = [
 "bitflags 2.9.4",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc1f0cbffaac4852523ce30d8bd3c5cdc873501d96ff467ca09b6767bb8cd5c0"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "semver"
version = "1.0.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d767eb0aabc880b29956c35734170f26ed551a859dbd361d140cdbeca61ab1e2"

[[package]]
name = "serde"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a8e94ea7f378bd32cbbd37198a4a91436180c5bb472411e48b5ec2e2124ae9e"
dependencies = [
 "serde_core",
 "serde_derive",
]

[[package]]
name = "serde_core"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41d385c7d4ca58e59fc732af25c3983b67ac852c1a25000afe1175de458b67ad"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d540f220d3187173da220f885ab66608367b6574e925011a9353e4badda91d79"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.145"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "402a6f66d8c709116cf22f558eab210f5a50187f702eb4d7e5ef38d9a7f1c79c"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
 "serde_core",
]

[[package]]
name = "serde_path_to_error"
version = "0.1.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "10a9ff822e371bb5403e391ecd83e182e0e77ba7f6fe0160b795797109d1b457"
dependencies = [
 "itoa",
 "serde",
 "serde_core",
]

[[package]]
name = "serde_spanned"
version = "0.6.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf41e0cfaf7226dca15e8197172c295a782857fcb97fad1808a166870dee75a3"
dependencies = [
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha3"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75872d278a8f37ef87fa0ddbda7802605cb18344497949862c0d4dcb291eba60"
dependencies = [
 "digest",
 "keccak",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signature"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"

[[package]]
name = "slab"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2ae44ef20feb57a68b23d846850f861394c2e02dc425a50098ae8c90267589"

[[package]]
name = "sled"
version = "0.34.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f96b4737c2ce5987354855aed3797279def4ebf734436c6aa4552cf8e169935"
dependencies = [
 "crc32fast",
 "crossbeam-epoch",
 "crossbeam-utils",
 "fs2",
 "fxhash",
 "libc",
 "log",
 "parking_lot",
]

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "socket2"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "socket2"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "233504af464074f9d066d7b5416c5f9b894a5862a6506e306f7b816cdd6f1807"
dependencies = [
 "libc",
 "windows-sys 0.59.0",
]

[[package]]
name = "spki"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
dependencies = [
 "der",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "2.0.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ede7c438028d4436d71104916910f5bb611972c5cfd7f89b8300a8186e6fada6"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sync_wrapper"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bf256ce5efdfa370213c1dabab5935a12e49f2c58d15e9eac2870d3b4f27263"
dependencies = [
 "futures-core",
]

[[package]]
name = "synstructure"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "system-configuration"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c879d448e9d986b661742763247d3693ed13609438cf3d006f51f5368a5ba6b"
dependencies = [
 "bitflags 2.9.4",
 "core-foundation",
 "system-configuration-sys",
]

[[package]]
name = "system-configuration-sys"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e1d1b10ced5ca923a1fcb8d03e96b8d3268065d724548c0211415ff6ac6bac4"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "tap"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369"

[[package]]
name = "tempfile"
version = "3.23.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2d31c77bdf42a745371d260a26ca7163f1e0924b64afa0b688e61b5a9fa02f16"
dependencies = [
 "fastrand",
 "getrandom 0.3.3",
 "once_cell",
 "rustix",
 "windows-sys 0.61.1",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl 1.0.69",
]

[[package]]
name = "thiserror"
version = "2.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f63587ca0f12b72a0600bcba1d40081f830876000bb46dd2337a3051618f4fc8"
dependencies = [
 "thiserror-impl 2.0.17",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thiserror-impl"
version = "2.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ff15c8ecd7de3849db632e14d18d2571fa09dfc5ed93479bc4485c7a517c913"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tinystr"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
dependencies = [
 "displaydoc",
 "zerovec",
]

[[package]]
name = "tinytemplate"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be4d6b5f19ff7664e8c98d03e2139cb510db9b0a60b55f8e8709b689d939b6bc"
dependencies = [
 "serde",
 "serde_json",
]

[[package]]
name = "tinyvec"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa5fdc3bce6191a1dbc8c02d5c8bffcf557bafa17c124c5264a458f1b0613fa"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "tmp-curve25519-dalek-h2c-do-not-use"
version = "4.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e8fd0fccdf5d6baf0fa00b541d8773139c1c7dfc0094280a7d66c30d079a09"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "curve25519-dalek-derive",
 "digest",
 "fiat-crypto",
 "group",
 "rand_core 0.6.4",
 "rustc_version",
 "subtle",
 "zeroize",
]

[[package]]
name = "tokio"
version = "1.47.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89e49afdadebb872d3145a5638b59eb0691ea23e46ca484037cfab3b76b95038"
dependencies = [
 "backtrace",
 "bytes",
 "io-uring",
 "libc",
 "mio",
 "pin-project-lite",
 "slab",
 "socket2 0.6.0",
 "tokio-macros",
 "windows-sys 0.59.0",
]

[[package]]
name = "tokio-macros"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio-native-tls"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
dependencies = [
 "native-tls",
 "tokio",
]

[[package]]
name = "tokio-rustls"
version = "0.26.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1729aa945f29d91ba541258c8df89027d5792d85a8841fb65e8bf0f4ede4ef61"
dependencies = [
 "rustls",
 "tokio",
]

[[package]]
name = "tokio-util"
version = "0.7.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14307c986784f72ef81c89db7d9e28d6ac26d16213b109ea501696195e6e3ce5"
dependencies = [
 "bytes",
 "futures-core",
 "futures-sink",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "toml"
version = "0.8.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc1beb996b9d83529a9e75c17a1686767d148d70663143c7854d8b4a09ced362"
dependencies = [
 "serde",
 "serde_spanned",
 "toml_datetime 0.6.11",
 "toml_edit 0.22.27",
]

[[package]]
name = "toml_datetime"
version = "0.6.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"
dependencies = [
 "serde",
]

[[package]]
name = "toml_datetime"
version = "0.7.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32f1085dec27c2b6632b04c80b3bb1b4300d6495d1e129693bdda7d91e72eec1"
dependencies = [
 "serde_core",
]

[[package]]
name = "toml_edit"
version = "0.22.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
dependencies = [
 "indexmap",
 "serde",
 "serde_spanned",
 "toml_datetime 0.6.11",
 "toml_write",
 "winnow",
]

[[package]]
name = "toml_edit"
version = "0.23.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3effe7c0e86fdff4f69cdd2ccc1b96f933e24811c5441d44904e8683e27184b"
dependencies = [
 "indexmap",
 "toml_datetime 0.7.2",
 "toml_parser",
 "winnow",
]

[[package]]
name = "toml_parser"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cf893c33be71572e0e9aa6dd15e6677937abd686b066eac3f8cd3531688a627"
dependencies = [
 "winnow",
]

[[package]]
name = "toml_write"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d99f8c9a7727884afe522e9bd5edbfc91a3312b36a77b5fb8926e4c31a41801"

[[package]]
name = "tower"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d039ad9159c98b70ecfd540b2573b97f7f52c3e8d9f8ad57a24b916a536975f9"
dependencies = [
 "futures-core",
 "futures-util",
 "pin-project-lite",
 "sync_wrapper",
 "tokio",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "tower-http"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adc82fd73de2a9722ac5da747f12383d2bfdb93591ee6c58486e0097890f05f2"
dependencies = [
 "bitflags 2.9.4",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "iri-string",
 "pin-project-lite",
 "tower",
 "tower-layer",
 "tower-service",
]

[[package]]
name = "tower-layer"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"

[[package]]
name = "tower-service"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "log",
 "pin-project-lite",
 "tracing-core",
]

[[package]]
name = "tracing-core"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
dependencies = [
 "once_cell",
]

[[package]]
name = "try-lock"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"

[[package]]
name = "typenum"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "562d481066bde0658276a35467c4af00bdc6ee726305698a55b86e61d7ad82bb"

[[package]]
name = "uint"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76f64bba2c53b04fcab63c01a7d7427eadc821e3bc48c34dc9ba29c501164b52"
dependencies = [
 "byteorder",
 "crunchy",
 "hex",
 "static_assertions",
]

[[package]]
name = "unarray"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eaea85b334db583fe3274d12b4cd1880032beab409c0d774be044d4480ab9a94"

[[package]]
name = "unicode-ident"
version = "1.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f63a545481291138910575129486daeaf8ac54aee4387fe7906919f7830c7d9d"

[[package]]
name = "unicode-xid"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebc1c04c71510c7f702b52b7c350734c9ff1295c464a03335b00bb84fc54f853"

[[package]]
name = "untrusted"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1"

[[package]]
name = "url"
version = "2.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08bc136a29a3d1758e07a9cca267be308aeebf5cfd5a10f3f67ab2097683ef5b"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
 "serde",
]

[[package]]
name = "utf8_iter"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "vrf-rfc9381"
version = "0.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "caafd984b0b1857db29c26455e80d39849524e60a657892560568ed427a327b3"
dependencies = [
 "digest",
 "getrandom 0.2.16",
 "sha2",
 "signature",
 "subtle",
 "thiserror 2.0.17",
 "tmp-curve25519-dalek-h2c-do-not-use",
 "zeroize",
]

[[package]]
name = "wait-timeout"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ac3b126d3914f9849036f826e054cbabdc8519970b8998ddaf3b5bd3c65f11"
dependencies = [
 "libc",
]

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "want"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
dependencies = [
 "try-lock",
]

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasi"
version = "0.14.7+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "883478de20367e224c0090af9cf5f9fa85bed63a95c1abf3afc5c083ebc06e8c"
dependencies = [
 "wasip2",
]

[[package]]
name = "wasip2"
version = "1.0.1+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0562428422c63773dad2c345a1882263bbf4d65cf3f42e90921f787ef5ad58e7"
dependencies = [
 "wit-bindgen",
]

[[package]]
name = "wasm-bindgen"
version = "0.2.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1da10c01ae9f1ae40cbfac0bac3b1e724b320abfcf52229f80b547c0d250e2d"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "671c9a5a66f49d8a47345ab942e2cb93c7d1d0339065d4f8139c486121b43b19"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.54"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e038d41e478cc73bae0ff9b36c60cff1c98b8f38f8d7e8061e79ee63608ac5c"
dependencies = [
 "cfg-if",
 "js-sys",
 "once_cell",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ca60477e4c59f5f2986c50191cd972e3a50d8a95603bc9434501cf156a9a119"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9f07d2f20d4da7b26400c9f4a0511e6e0345b040694e8a75bd41d578fa4421d7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bad67dc8b2a1a6e5448428adec4c3e84c43e561d8c9ee8a9e5aabeb193ec41d1"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "web-sys"
version = "0.3.81"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9367c417a924a74cae129e6a2ae3b47fabb1f8995595ab474029da749a8be120"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "web-time"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a6580f308b1fad9207618087a65c04e7a10bc77e02c8e84e9b00dd4b12fa0bb"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "webpki-roots"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e8983c3ab33d6fb807cfcdad2491c4ea8cbc8ed839181c7dfd9c67c83e261b2"
dependencies = [
 "rustls-pki-types",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2a7b1c03c876122aa43f3020e6c3c3ee5c05081c9a00739faf7503aeba10d22"
dependencies = [
 "windows-sys 0.61.1",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-link"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"

[[package]]
name = "windows-link"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "45e46c0661abb7180e7b9c281db115305d49ca1709ab8242adf09666d2173c65"

[[package]]
name = "windows-registry"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b8a9ed28765efc97bbc954883f4e6796c33a06546ebafacbabee9696967499e"
dependencies = [
 "windows-link 0.1.3",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-result"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
dependencies = [
 "windows-link 0.1.3",
]

[[package]]
name = "windows-strings"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
dependencies = [
 "windows-link 0.1.3",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets 0.53.4",
]

[[package]]
name = "windows-sys"
version = "0.61.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f109e41dd4a3c848907eb83d5a42ea98b3769495597450cf6d153507b166f0f"
dependencies = [
 "windows-link 0.2.0",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm 0.52.6",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.53.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2d42b7b7f66d2a06854650af09cfdf8713e427a439c97ad65a6375318033ac4b"
dependencies = [
 "windows-link 0.2.0",
 "windows_aarch64_gnullvm 0.53.0",
 "windows_aarch64_msvc 0.53.0",
 "windows_i686_gnu 0.53.0",
 "windows_i686_gnullvm 0.53.0",
 "windows_i686_msvc 0.53.0",
 "windows_x86_64_gnu 0.53.0",
 "windows_x86_64_gnullvm 0.53.0",
 "windows_x86_64_msvc 0.53.0",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "86b8d5f90ddd19cb4a147a5fa63ca848db3df085e25fee3cc10b39b6eebae764"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7651a1f62a11b8cbd5e0d42526e55f2c99886c77e007179efff86c2b137e66c"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1dc67659d35f387f5f6c479dc4e28f1d4bb90ddd1a5d3da2e5d97b42d6272c3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ce6ccbdedbf6d6354471319e781c0dfef054c81fbc7cf83f338a4296c0cae11"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_i686_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "581fee95406bb13382d2f65cd4a908ca7b1e4c2f1917f143ba16efe98a589b5d"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e55b5ac9ea33f2fc1716d1742db15574fd6fc8dadc51caab1c16a3d3b4190ba"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a6e035dd0599267ce1ee132e51c27dd29437f63325753051e71dd9e42406c57"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "271414315aff87387382ec3d271b52d7ae78726f5d44ac98b4f4030c91880486"

[[package]]
name = "winnow"
version = "0.7.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "21a0236b59786fed61e2a80582dd500fe61f18b5dca67a4a067d0bc9039339cf"
dependencies = [
 "memchr",
]

[[package]]
name = "wit-bindgen"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f17a85883d4e6d00e8a97c586de764dabcc06133f7f1d55dce5cdc070ad7fe59"

[[package]]
name = "writeable"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"

[[package]]
name = "wyz"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed"
dependencies = [
 "tap",
]

[[package]]
name = "yoke"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
dependencies = [
 "serde",
 "stable_deref_trait",
 "yoke-derive",
 "zerofrom",
]

[[package]]
name = "yoke-derive"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zerocopy"
version = "0.8.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0894878a5fa3edfd6da3f88c4805f4c8558e2b996227a3d864f47fe11e38282c"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88d2b8d9c68ad2b9e4340d7832716a4d21a22a1154777ad56ea55c51a9cf3831"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zerofrom"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
dependencies = [
 "zerofrom-derive",
]

[[package]]
name = "zerofrom-derive"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zeroize"
version = "1.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b97154e67e32c85465826e8bcc1c59429aaaf107c1e4a9e53c8d8ccd5eff88d0"
dependencies = [
 "zeroize_derive",
]

[[package]]
name = "zeroize_derive"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zerotrie"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
dependencies = [
 "displaydoc",
 "yoke",
 "zerofrom",
]

[[package]]
name = "zerovec"
version = "0.11.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7aa2bd55086f1ab526693ecbe444205da57e25f4489879da80635a46d90e73b"
dependencies = [
 "yoke",
 "zerofrom",
 "zerovec-derive",
]

[[package]]
name = "zerovec-derive"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

'PROJECT_ROOT'>obex-alpha>Cargo.toml
[workspace]
members = [
    "crates/obex_primitives",
    "crates/obex_alpha_i",
    "crates/obex_alpha_ii",
    "crates/obex_alpha_iii",
    "crates/obex_alpha_t",
    "crates/e2e",
    "crates/obex_node",
    "crates/obex_tool",
]
resolver = "2"

[workspace.package]
edition = "2021"
license = "MIT OR Apache-2.0"
version = "1.0.0"
authors = ["Obex Labs <engineering@obex.example>"]

[workspace.lints.rust]
unsafe_code = "forbid"
warnings = "deny"



'PROJECT_ROOT'>obex-alpha>crates>e2e>Cargo.toml
[package]
name = "obex_e2e"
version = "1.0.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[dependencies]
obex_primitives = { path = "../obex_primitives" }
obex_alpha_i = { path = "../obex_alpha_i" }
obex_alpha_ii = { path = "../obex_alpha_ii" }
obex_alpha_iii = { path = "../obex_alpha_iii" }
obex_alpha_t = { path = "../obex_alpha_t" }

[dev-dependencies]
hex = "0.4"



'PROJECT_ROOT'>obex-alpha>crates>e2e>src>lib.rs
#![forbid(unsafe_code)]
#![deny(warnings)]

//! E2E scaffolding for 3-slot pipeline tests (beacon v1)

pub use obex_primitives::Hash256 as _obex_sha3_anchor_e2e;

'PROJECT_ROOT'>obex-alpha>crates>e2e>tests>conformance.rs
#![allow(unused)]
use obex_alpha_i::{decode_partrec, encode_partrec, CHALLENGES_Q};
use obex_alpha_ii::{deserialize_header, obex_header_id};
use obex_alpha_iii::enc_ticket_leaf;
use obex_primitives::merkle_root;
use obex_primitives::{constants, h_tag, le_bytes, Hash256};
use std::{env, fs, path::PathBuf};
struct DummyProviders;
impl obex_alpha_ii::TicketRootProvider for DummyProviders {
    fn compute_ticket_root(&self, _s: u64) -> Hash256 {
        h_tag(constants::TAG_MERKLE_EMPTY, &[])
    }
}
impl obex_alpha_ii::PartRootProvider for DummyProviders {
    fn compute_part_root(&self, _s: u64) -> Hash256 {
        h_tag(constants::TAG_MERKLE_EMPTY, &[])
    }
}
impl obex_alpha_ii::TxRootProvider for DummyProviders {
    fn compute_txroot(&self, _s: u64) -> Hash256 {
        h_tag(constants::TAG_MERKLE_EMPTY, &[])
    }
}

fn goldens_dir() -> Option<PathBuf> {
    if let Ok(p) = env::var("GOLDENS_DIR") {
        return Some(PathBuf::from(p));
    }
    let local = PathBuf::from("tests/golden");
    if local.exists() {
        Some(local)
    } else {
        None
    }
}

fn read_bytes(p: &PathBuf) -> Option<Vec<u8>> {
    fs::read(p).ok()
}

#[test]
fn conformance_header_and_beacon_v1() {
    let Some(root) = goldens_dir() else {
        eprintln!("goldens missing; skipping");
        return;
    };
    let hdr_path = root.join("header/header.bin");
    let id_path = root.join("header/header_id.bin");
    let Some(hdr_bytes) = read_bytes(&hdr_path) else {
        eprintln!("no header.bin");
        return;
    };
    let Some(id_bytes) = read_bytes(&id_path) else {
        eprintln!("no header_id.bin");
        return;
    };
    let header = deserialize_header(&hdr_bytes).expect("decode header");
    // Beacon v1 checks
    assert!(header.vdf_pi.is_empty() && header.vdf_ell.is_empty());
    let edge = h_tag(constants::TAG_VDF_EDGE, &[&header.vdf_y_core]);
    assert_eq!(edge, header.vdf_y_edge);
    // Header ID
    let id = obex_header_id(&header);
    assert_eq!(id.as_slice(), id_bytes.as_slice());
}

#[test]
fn conformance_alpha_i_partrec_roundtrip() {
    let Some(root) = goldens_dir() else {
        eprintln!("goldens missing; skipping");
        return;
    };
    let bytes_path = root.join("alpha_i/partrec.bin");
    let Some(bytes) = read_bytes(&bytes_path) else {
        eprintln!("no partrec.bin");
        return;
    };
    let rec = decode_partrec(&bytes).expect("decode");
    assert_eq!(rec.challenges.len(), CHALLENGES_Q);
    let re = encode_partrec(&rec).expect("encode");
    assert_eq!(re, bytes);
}

#[test]
fn conformance_alpha_iii_ticket_root() {
    let Some(root) = goldens_dir() else {
        eprintln!("goldens missing; skipping");
        return;
    };
    let leaves_path = root.join("alpha_iii/ticket_leaves.bin");
    let root_path = root.join("alpha_iii/ticket_root.bin");
    let Some(concat) = read_bytes(&leaves_path) else {
        eprintln!("no ticket_leaves.bin");
        return;
    };
    let Some(root_bytes) = read_bytes(&root_path) else {
        eprintln!("no ticket_root.bin");
        return;
    };
    let mut leaves = Vec::new();
    // Leaf length = 248 (see BYTE_LAYOUTS.md)
    const L: usize = 248;
    if concat.len() % L != 0 {
        panic!("bad leaves concat length");
    }
    let mut i = 0usize;
    while i < concat.len() {
        leaves.push(concat[i..i + L].to_vec());
        i += L;
    }
    let local_root = merkle_root(&leaves);
    assert_eq!(local_root.as_slice(), root_bytes.as_slice());
}

#[test]
fn conformance_negatives() {
    let Some(root) = goldens_dir() else {
        eprintln!("goldens missing; skipping");
        return;
    };
    // 1) vdf y_edge mismatch
    if let (Some(y_core), Some(bad_edge)) = (
        read_bytes(&root.join("vdf/y_core.bin")),
        read_bytes(&root.join("negatives/vdf_bad_y_edge.bin")),
    ) {
        let calc = h_tag(constants::TAG_VDF_EDGE, &[y_core.as_slice()]);
        assert_ne!(calc.as_slice(), bad_edge.as_slice());
    }
    // 2) header with non-empty pi should fail validate against a dummy parent
    if let Some(bad_hdr) = read_bytes(&root.join("negatives/header_bad_pi.bin")) {
        let h = deserialize_header(&bad_hdr).expect("decode bad header");
        // Create dummy parent with matching slot-1 and id
        let parent = obex_alpha_ii::Header {
            parent_id: [0u8; 32],
            slot: h.slot.saturating_sub(1),
            obex_version: h.obex_version,
            seed_commit: h_tag(
                constants::TAG_SLOT_SEED,
                &[&h.parent_id, &le_bytes::<8>(u128::from(h.slot))],
            ),
            vdf_y_core: [2u8; 32],
            vdf_y_edge: h_tag(constants::TAG_VDF_EDGE, &[&[2u8; 32]]),
            vdf_pi: vec![],
            vdf_ell: vec![],
            ticket_root: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
            part_root: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
            txroot_prev: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
        };
        let providers = DummyProviders;
        let res = obex_alpha_ii::validate_header(
            &h,
            &parent,
            &providers,
            &providers,
            &providers,
            h.obex_version,
        );
        assert!(res.is_err());
    }
    // 3) truncated partrec must fail to decode
    if let Some(trunc) = read_bytes(&root.join("negatives/partrec_truncated.bin")) {
        assert!(decode_partrec(&trunc).is_err());
    }
}

'PROJECT_ROOT'>obex-alpha>crates>e2e>tests>equalities.rs
#![allow(unused)]
use obex_alpha_ii::{
    obex_header_id, validate_header, Header, PartRootProvider, TicketRootProvider, TxRootProvider,
    OBEX_ALPHA_II_VERSION,
};
use obex_alpha_iii::{enc_ticket_leaf, TicketRecord};
use obex_primitives::{constants, h_tag, le_bytes, merkle_root, Hash256};

struct FixedProviders {
    ticket_root: Hash256,
    part_root: Hash256,
    txroot_prev: Hash256,
}
impl TicketRootProvider for FixedProviders {
    fn compute_ticket_root(&self, _s: u64) -> Hash256 {
        self.ticket_root
    }
}
impl PartRootProvider for FixedProviders {
    fn compute_part_root(&self, _s: u64) -> Hash256 {
        self.part_root
    }
}
impl TxRootProvider for FixedProviders {
    fn compute_txroot(&self, _s: u64) -> Hash256 {
        self.txroot_prev
    }
}

fn part_root_from_pks(pks: &mut Vec<[u8; 32]>) -> Hash256 {
    pks.sort_unstable();
    pks.dedup();
    let leaves: Vec<Vec<u8>> = pks
        .iter()
        .map(|pk| {
            let mut b = Vec::with_capacity(64);
            b.extend_from_slice(&h_tag(constants::TAG_PART_LEAF, &[]));
            b.extend_from_slice(pk);
            b
        })
        .collect();
    merkle_root(&leaves)
}

#[test]
fn validate_header_with_nonempty_roots() {
    // Parent at slot 0
    let parent = Header {
        parent_id: [0u8; 32],
        slot: 0,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit: h_tag(constants::TAG_SLOT_SEED, &[&[0u8; 32], &le_bytes::<8>(0)]),
        vdf_y_core: [2u8; 32],
        vdf_y_edge: h_tag(constants::TAG_VDF_EDGE, &[&[2u8; 32]]),
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
        part_root: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
        txroot_prev: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
    };
    let parent_id_hdr = obex_header_id(&parent);
    let s = 1u64;

    // Build ticket leaves/root
    let rec = TicketRecord {
        ticket_id: [0u8; 32],
        txid: [1u8; 32],
        sender: [2u8; 32],
        nonce: 0,
        amount_u: 1000,
        fee_u: 10,
        s_admit: s,
        s_exec: s,
        commit_hash: [3u8; 32],
    };
    let ticket_leaves: Vec<Vec<u8>> = vec![enc_ticket_leaf(&rec)];
    let ticket_root = merkle_root(&ticket_leaves);

    // Build part root from two pks
    let mut pks = vec![[1u8; 32], [2u8; 32]];
    let part_root = part_root_from_pks(&mut pks);

    // Build header with fixed roots
    let seed_commit = h_tag(
        constants::TAG_SLOT_SEED,
        &[&parent_id_hdr, &le_bytes::<8>(u128::from(s))],
    );
    let y_core = [5u8; 32];
    let y_edge = h_tag(constants::TAG_VDF_EDGE, &[&y_core]);
    let h = Header {
        parent_id: parent_id_hdr,
        slot: s,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit,
        vdf_y_core: y_core,
        vdf_y_edge: y_edge,
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root,
        part_root,
        txroot_prev: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
    };
    let providers = FixedProviders {
        ticket_root,
        part_root,
        txroot_prev: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
    };
    assert!(validate_header(
        &h,
        &parent,
        &providers,
        &providers,
        &providers,
        OBEX_ALPHA_II_VERSION
    )
    .is_ok());

    // Flip a root to ensure mismatch is detected
    let mut bad = h.clone();
    bad.ticket_root[0] ^= 1;
    assert!(validate_header(
        &bad,
        &parent,
        &providers,
        &providers,
        &providers,
        OBEX_ALPHA_II_VERSION
    )
    .is_err());
}

'PROJECT_ROOT'>obex-alpha>crates>e2e>tests>goldens.rs
#![allow(unused)]
use obex_alpha_i::*;
use obex_alpha_ii::*;
use obex_alpha_iii::*;
use obex_primitives::{constants, h_tag, le_bytes, Hash256};

struct DummyVrf;
impl EcVrfVerifier for DummyVrf {
    fn verify(&self, _vk: &[u8; 32], _alpha32: &Hash256, pi: &[u8]) -> Option<Vec<u8>> {
        if pi.len() != 80 {
            None
        } else {
            Some(vec![5u8; 64])
        }
    }
}

fn empty_root() -> Hash256 {
    h_tag(constants::TAG_MERKLE_EMPTY, &[])
}

#[test]
fn golden_header_id_and_beacon_v1() {
    // Parent at slot 0
    let parent = Header {
        parent_id: [0u8; 32],
        slot: 0,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit: h_tag(constants::TAG_SLOT_SEED, &[&[0u8; 32], &le_bytes::<8>(0)]),
        vdf_y_core: [3u8; 32],
        vdf_y_edge: h_tag(constants::TAG_VDF_EDGE, &[&[3u8; 32]]),
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root: empty_root(),
        part_root: empty_root(),
        txroot_prev: empty_root(),
    };
    let parent_id_hdr = obex_header_id(&parent);
    let s = 1u64;
    let seed_commit = h_tag(
        constants::TAG_SLOT_SEED,
        &[&parent_id_hdr, &le_bytes::<8>(u128::from(s))],
    );
    let y_core = [5u8; 32];
    let y_edge = h_tag(constants::TAG_VDF_EDGE, &[&y_core]);
    let h = Header {
        parent_id: parent_id_hdr,
        slot: s,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit,
        vdf_y_core: y_core,
        vdf_y_edge: y_edge,
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root: empty_root(),
        part_root: empty_root(),
        txroot_prev: empty_root(),
    };
    let id = obex_header_id(&h);
    assert_eq!(id, obex_header_id(&h));
    let providers = TestProviders;
    assert!(validate_header(
        &h,
        &parent,
        &providers,
        &providers,
        &providers,
        OBEX_ALPHA_II_VERSION
    )
    .is_ok());
}

struct TestProviders;
impl TicketRootProvider for TestProviders {
    fn compute_ticket_root(&self, _s: u64) -> Hash256 {
        empty_root()
    }
}
impl PartRootProvider for TestProviders {
    fn compute_part_root(&self, _s: u64) -> Hash256 {
        empty_root()
    }
}
impl TxRootProvider for TestProviders {
    fn compute_txroot(&self, _s: u64) -> Hash256 {
        empty_root()
    }
}

#[test]
fn golden_participation_set_root() {
    // Compute expected participation root from sorted pks as per spec (without verifying partrecs here)
    let mut pks = vec![[1u8; 32], [2u8; 32]];
    pks.sort_unstable();
    let leaves: Vec<Vec<u8>> = pks
        .iter()
        .map(|pk| {
            let mut b = Vec::with_capacity(64);
            b.extend_from_slice(&h_tag(constants::TAG_PART_LEAF, &[]));
            b.extend_from_slice(pk);
            b
        })
        .collect();
    let root = obex_primitives::merkle_root(&leaves);
    assert_ne!(root, empty_root());
}

#[test]
fn golden_ticket_root() {
    let mut st = AlphaIIIState::default();
    let rec = TicketRecord {
        ticket_id: [0u8; 32],
        txid: [1u8; 32],
        sender: [2u8; 32],
        nonce: 0,
        amount_u: 1000,
        fee_u: 10,
        s_admit: 1,
        s_exec: 1,
        commit_hash: [3u8; 32],
    };
    st.admitted_by_slot.insert(1, vec![rec]);
    let (_leaves, root) = build_ticket_root_for_slot(1, &st);
    // Empty vs non-empty: different roots
    assert_ne!(root, empty_root());
}

'PROJECT_ROOT'>obex-alpha>crates>e2e>tests>golden_bytes.rs
#![allow(unused)]
use obex_alpha_i::{decode_partrec, encode_partrec};
use obex_alpha_ii::{obex_header_id, serialize_header, Header, OBEX_ALPHA_II_VERSION};
use obex_primitives::{constants, h_tag, le_bytes, merkle_root, Hash256};
use std::fs;
use std::path::PathBuf;

fn golden_dir() -> PathBuf {
    let mut p = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    p.push("../../tests/golden");
    p
}

#[test]
fn golden_alpha_i_partrec_roundtrip_bytes() {
    let mut p = golden_dir();
    p.push("alpha_i/partrec.bin");
    let bytes = fs::read(p).expect("read partrec.bin");
    let rec = decode_partrec(&bytes).expect("decode partrec");
    let enc = encode_partrec(&rec).expect("encode partrec");
    assert_eq!(bytes, enc, "partrec bytes must roundtrip exactly");
}

#[test]
fn golden_header_bytes_and_id_match() {
    let mut dir = golden_dir();
    // Read VDF goldens
    let y_core = {
        let mut p = dir.clone();
        p.push("vdf/y_core.bin");
        let b = fs::read(p).expect("read y_core.bin");
        let mut a = [0u8; 32];
        a.copy_from_slice(&b);
        a
    };
    let y_edge_file = {
        let mut p = dir.clone();
        p.push("vdf/y_edge.bin");
        let b = fs::read(p).expect("read y_edge.bin");
        let mut a = [0u8; 32];
        a.copy_from_slice(&b);
        a
    };
    // Build expected header per GenGoldens: parent_id=0, slot=1, empty roots
    let parent_id = [0u8; 32];
    let slot = 1u64;
    let seed_commit = h_tag(
        constants::TAG_SLOT_SEED,
        &[&parent_id, &le_bytes::<8>(u128::from(slot))],
    );
    let y_edge = h_tag(constants::TAG_VDF_EDGE, &[&y_core]);
    assert_eq!(y_edge, y_edge_file, "y_edge must equal H(edge,[y_core])");
    let header = Header {
        parent_id,
        slot,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit,
        vdf_y_core: y_core,
        vdf_y_edge: y_edge,
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
        part_root: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
        txroot_prev: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
    };
    let hdr_bytes = serialize_header(&header);
    let hdr_id = obex_header_id(&header);
    // Compare to goldens
    let mut p_hdr = dir.clone();
    p_hdr.push("header/header.bin");
    let hdr_bin_file = fs::read(p_hdr).expect("read header.bin");
    assert_eq!(hdr_bytes, hdr_bin_file, "header bytes must match golden");
    let mut p_id = dir.clone();
    p_id.push("header/header_id.bin");
    let hdr_id_file = fs::read(p_id).expect("read header_id.bin");
    assert_eq!(hdr_id.as_slice(), hdr_id_file.as_slice(), "header id must match golden");
}

#[test]
fn golden_alpha_iii_ticket_root_matches() {
    let mut dir = golden_dir();
    let mut p_leaves = dir.clone();
    p_leaves.push("alpha_iii/ticket_leaves.bin");
    let buf = fs::read(p_leaves).expect("read ticket_leaves.bin");
    let mut p_root = dir.clone();
    p_root.push("alpha_iii/ticket_root.bin");
    let root_bytes = fs::read(p_root).expect("read ticket_root.bin");
    let mut expected_root = [0u8; 32];
    expected_root.copy_from_slice(&root_bytes);
    // Split leaves by canonical length 216 and compute root
    const LEAF_LEN: usize = 216;
    assert!(buf.len() % LEAF_LEN == 0, "concat length must be multiple of 216");
    let mut leaves: Vec<Vec<u8>> = Vec::with_capacity(buf.len() / LEAF_LEN);
    let mut i = 0usize;
    while i < buf.len() {
        leaves.push(buf[i..i + LEAF_LEN].to_vec());
        i += LEAF_LEN;
    }
    let root = merkle_root(&leaves);
    assert_eq!(root, expected_root, "ticket root must match golden");
}



'PROJECT_ROOT'>obex-alpha>crates>e2e>tests>pipeline.rs
#![allow(unused)]
use obex_alpha_ii::{
    obex_header_id, validate_header, Header, PartRootProvider, TicketRootProvider, TxRootProvider,
    OBEX_ALPHA_II_VERSION,
};
use obex_primitives::{constants, h_tag, le_bytes, Hash256};

struct ZeroRoots;
impl TicketRootProvider for ZeroRoots {
    fn compute_ticket_root(&self, _s: u64) -> Hash256 {
        [0u8; 32]
    }
}
impl PartRootProvider for ZeroRoots {
    fn compute_part_root(&self, _s: u64) -> Hash256 {
        [0u8; 32]
    }
}
impl TxRootProvider for ZeroRoots {
    fn compute_txroot(&self, _s: u64) -> Hash256 {
        [0u8; 32]
    }
}

fn empty_root() -> Hash256 {
    h_tag(constants::TAG_MERKLE_EMPTY, &[])
}

#[test]
fn header_build_validate_beacon_v1_roundtrip() {
    let parent = Header {
        parent_id: [9u8; 32],
        slot: 7,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit: [1u8; 32],
        vdf_y_core: [2u8; 32],
        vdf_y_edge: h_tag(constants::TAG_VDF_EDGE, &[&[2u8; 32]]),
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root: empty_root(),
        part_root: empty_root(),
        txroot_prev: empty_root(),
    };
    let parent_id_hdr = obex_header_id(&parent);
    let s = parent.slot + 1;
    let seed_commit = h_tag(
        constants::TAG_SLOT_SEED,
        &[&parent_id_hdr, &le_bytes::<8>(u128::from(s))],
    );
    let y_core = h_tag(constants::TAG_VDF_YCORE, &[&[5u8; 32]]);
    let y_edge = h_tag(constants::TAG_VDF_EDGE, &[&y_core]);
    let providers = ZeroRoots;
    let h = Header {
        parent_id: parent_id_hdr,
        slot: s,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit,
        vdf_y_core: y_core,
        vdf_y_edge: y_edge,
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root: providers.compute_ticket_root(s),
        part_root: providers.compute_part_root(s),
        txroot_prev: providers.compute_txroot(parent.slot),
    };
    assert!(validate_header(
        &h,
        &parent,
        &providers,
        &providers,
        &providers,
        OBEX_ALPHA_II_VERSION
    )
    .is_ok());
}

'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_i>Cargo.toml
[package]
name = "obex_alpha_i"
version = "1.0.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[dependencies]
obex_primitives = { path = "../obex_primitives" }
ed25519-dalek = { version = "2.1", default-features = false, features = ["pkcs8"] }
thiserror = "1.0"

[dev-dependencies]
criterion = "0.5"
proptest = "1.5"

[[bench]]
name = "alpha_i_verify"
harness = false



'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_i>benches>alpha_i_verify.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use obex_alpha_i::*;
use obex_primitives::Hash256;

struct DummyVrf;
impl EcVrfVerifier for DummyVrf {
    fn verify(&self, _vk: &[u8; 32], _alpha32: &Hash256, pi: &[u8]) -> Option<Vec<u8>> {
        if pi.len() != 80 {
            None
        } else {
            Some(vec![5u8; 64])
        }
    }
}

fn bench_alpha_i_verify(c: &mut Criterion) {
    let vrf = DummyVrf;
    let slot = 1u64;
    let parent_id = [0u8; 32];
    let mut rec = ObexPartRec {
        version: OBEX_ALPHA_I_VERSION,
        slot,
        pk_ed25519: [1u8; 32],
        vrf_pk: [2u8; 32],
        y_edge_prev: [3u8; 32],
        alpha: [4u8; 32],
        vrf_y: vec![5u8; 64],
        vrf_pi: vec![6u8; 80],
        seed: [7u8; 32],
        root: [8u8; 32],
        challenges: Vec::new(),
        sig: [13u8; 64],
    };
    rec.challenges = (0..CHALLENGES_Q)
        .map(|_| ChallengeOpen {
            idx: 1,
            li: [9u8; 32],
            pi: MerklePathLite { siblings: vec![] },
            lim1: [10u8; 32],
            pim1: MerklePathLite { siblings: vec![] },
            lj: [11u8; 32],
            pj: MerklePathLite { siblings: vec![] },
            lk: [12u8; 32],
            pk_: MerklePathLite { siblings: vec![] },
        })
        .collect();
    c.bench_function("alpha_i_verify_q96", |b| {
        b.iter(|| {
            let _ = obex_verify_partrec(
                black_box(&rec),
                black_box(slot),
                black_box(&parent_id),
                &vrf,
            );
        });
    });
}

criterion_group!(benches, bench_alpha_i_verify);
criterion_main!(benches);

'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_i>src>lib.rs
#![forbid(unsafe_code)]
#![deny(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(
    clippy::module_name_repetitions,
    clippy::missing_errors_doc,
    clippy::missing_panics_doc,
    clippy::result_large_err
)]

//! α‑I — Participation Engine (VRF + RAM‑hard + Merkle), per ALPHA_I_SPEC.md

use ed25519_dalek::{Signature, VerifyingKey};
use obex_primitives::{
    constants, ct_eq_hash, h_tag, le_bytes, merkle_root, merkle_verify_leaf, u64_from_le, Hash256,
};
use thiserror::Error;

pub const OBEX_ALPHA_I_VERSION: u32 = 1;
pub const MEM_MIB: usize = 512;
pub const LABEL_BYTES: usize = 32;
pub const N_LABELS: usize = (MEM_MIB * 1_048_576) / LABEL_BYTES; // 16,777,216
pub const PASSES: u32 = 3;
pub const CHALLENGES_Q: usize = 96;
pub const MAX_PARTREC_SIZE: usize = 600_000;

pub type Pk32 = [u8; 32];

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct MerklePathLite {
    pub siblings: Vec<Hash256>,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ChallengeOpen {
    pub idx: u64,
    pub li: Hash256,
    pub pi: MerklePathLite,
    pub lim1: Hash256,
    pub pim1: MerklePathLite,
    pub lj: Hash256,
    pub pj: MerklePathLite,
    pub lk: Hash256,
    pub pk_: MerklePathLite,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ObexPartRec {
    pub version: u32,
    pub slot: u64,
    pub pk_ed25519: Pk32,
    pub vrf_pk: Pk32,
    pub y_edge_prev: Hash256,
    pub alpha: Hash256,
    pub vrf_y: Vec<u8>,  // 64 bytes
    pub vrf_pi: Vec<u8>, // 80 bytes
    pub seed: Hash256,
    pub root: Hash256,
    pub challenges: Vec<ChallengeOpen>, // len == 96
    pub sig: [u8; 64],
}

pub trait EcVrfVerifier {
    fn verify(&self, vk: &Pk32, alpha32: &Hash256, pi: &[u8]) -> Option<Vec<u8>>;
}

#[inline]
fn obex_alpha(parent_id: &Hash256, slot: u64, y_prev: &Hash256, vrf_pk: &Pk32) -> Hash256 {
    h_tag(
        constants::TAG_ALPHA,
        &[parent_id, &le_bytes::<8>(u128::from(slot)), y_prev, vrf_pk],
    )
}

#[inline]
fn obex_seed(y_prev: &Hash256, pk: &Pk32, vrf_y: &[u8]) -> Hash256 {
    h_tag(constants::TAG_SEED, &[y_prev, pk, vrf_y])
}

#[inline]
fn idx_j(seed: &Hash256, i: u64, p: u32) -> u64 {
    let b = h_tag(
        constants::TAG_IDX,
        &[
            seed,
            &le_bytes::<8>(u128::from(i)),
            &le_bytes::<4>(u128::from(p)),
            &[0x00],
        ],
    );
    if i == 0 {
        0
    } else {
        u64_from_le(&b[..8]) % i
    }
}

#[inline]
fn idx_k(seed: &Hash256, i: u64, p: u32) -> u64 {
    let b = h_tag(
        constants::TAG_IDX,
        &[
            seed,
            &le_bytes::<8>(u128::from(i)),
            &le_bytes::<4>(u128::from(p)),
            &[0x01],
        ],
    );
    if i == 0 {
        0
    } else {
        u64_from_le(&b[..8]) % i
    }
}

#[inline]
fn label_update(seed: &Hash256, i: u64, l_im1: &Hash256, l_j: &Hash256, l_k: &Hash256) -> Hash256 {
    h_tag(
        constants::TAG_LBL,
        &[seed, &le_bytes::<8>(u128::from(i)), l_im1, l_j, l_k],
    )
}

#[inline]
fn chal_index(y_prev: &Hash256, root: &Hash256, vrf_y: &[u8], t: u32) -> u64 {
    let b = h_tag(
        constants::TAG_CHAL,
        &[y_prev, root, vrf_y, &le_bytes::<4>(u128::from(t))],
    );
    1 + (u64_from_le(&b[..8]) % ((N_LABELS as u64) - 1))
}

struct Transcript<'a> {
    version: u32,
    slot: u64,
    pk: &'a Pk32,
    vrf_pk: &'a Pk32,
    y_prev: &'a Hash256,
    alpha: &'a Hash256,
    vrf_y: &'a [u8],
    root: &'a Hash256,
}

fn partrec_msg(t: &Transcript<'_>) -> Hash256 {
    h_tag(
        constants::TAG_PARTREC,
        &[
            &le_bytes::<4>(u128::from(t.version)),
            t.pk,
            t.vrf_pk,
            &le_bytes::<8>(u128::from(t.slot)),
            t.y_prev,
            t.alpha,
            t.vrf_y,
            t.root,
        ],
    )
}

fn verify_sig(pk: &Pk32, msg: &Hash256, sig: &[u8; 64]) -> bool {
    match (VerifyingKey::from_bytes(pk), Signature::from_slice(sig)) {
        (Ok(vk), Ok(sig_d)) => vk.verify_strict(msg, &sig_d).is_ok(),
        _ => false,
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum VerifyErr {
    VersionMismatch,
    SlotMismatch,
    ChallengesLen,
    AlphaMismatch,
    VrfVerifyFailed,
    VrfOutputMismatch,
    SeedMismatch,
    SigInvalid,
    ChalIndexMismatch,
    ChalIndexBounds,
    JOrKOutOfRange,
    MerkleLiInvalid,
    MerkleLim1Invalid,
    MerkleLjInvalid,
    MerkleLkInvalid,
    LabelEquationMismatch,
}

pub fn obex_check_partrec(
    rec: &ObexPartRec,
    slot: u64,
    parent_id: &Hash256,
    vrf: &impl EcVrfVerifier,
) -> Result<(), VerifyErr> {
    if rec.version != OBEX_ALPHA_I_VERSION {
        return Err(VerifyErr::VersionMismatch);
    }
    if rec.slot != slot {
        return Err(VerifyErr::SlotMismatch);
    }
    if rec.challenges.len() != CHALLENGES_Q {
        return Err(VerifyErr::ChallengesLen);
    }

    let alpha = obex_alpha(parent_id, slot, &rec.y_edge_prev, &rec.vrf_pk);
    if !ct_eq_hash(&alpha, &rec.alpha) {
        return Err(VerifyErr::AlphaMismatch);
    }
    let Some(vrf_y_check) = vrf.verify(&rec.vrf_pk, &alpha, &rec.vrf_pi) else {
        return Err(VerifyErr::VrfVerifyFailed);
    };
    if vrf_y_check.as_slice() != rec.vrf_y.as_slice() {
        return Err(VerifyErr::VrfOutputMismatch);
    }

    let seed_expected = obex_seed(&rec.y_edge_prev, &rec.pk_ed25519, &rec.vrf_y);
    if !ct_eq_hash(&seed_expected, &rec.seed) {
        return Err(VerifyErr::SeedMismatch);
    }

    let msg = partrec_msg(&Transcript {
        version: rec.version,
        slot: rec.slot,
        pk: &rec.pk_ed25519,
        vrf_pk: &rec.vrf_pk,
        y_prev: &rec.y_edge_prev,
        alpha: &rec.alpha,
        vrf_y: &rec.vrf_y,
        root: &rec.root,
    });
    if !verify_sig(&rec.pk_ed25519, &msg, &rec.sig) {
        return Err(VerifyErr::SigInvalid);
    }

    let last_pass = PASSES - 1;
    for (t, ch) in rec.challenges.iter().enumerate() {
        let Ok(t_u32) = u32::try_from(t) else {
            return Err(VerifyErr::ChalIndexBounds);
        };
        let i = chal_index(&rec.y_edge_prev, &rec.root, &rec.vrf_y, t_u32);
        if ch.idx != i {
            return Err(VerifyErr::ChalIndexMismatch);
        }
        if !(i > 0 && usize::try_from(i).is_ok_and(|ii| ii < N_LABELS)) {
            return Err(VerifyErr::ChalIndexBounds);
        }
        let j = idx_j(&rec.seed, i, last_pass);
        let k = idx_k(&rec.seed, i, last_pass);
        if !(j < i && k < i) {
            return Err(VerifyErr::JOrKOutOfRange);
        }
        if !merkle_verify_leaf(
            &rec.root,
            &ch.li,
            &obex_primitives::MerklePath {
                siblings: ch.pi.siblings.clone(),
                index: i,
            },
        ) {
            return Err(VerifyErr::MerkleLiInvalid);
        }
        if !merkle_verify_leaf(
            &rec.root,
            &ch.lim1,
            &obex_primitives::MerklePath {
                siblings: ch.pim1.siblings.clone(),
                index: i - 1,
            },
        ) {
            return Err(VerifyErr::MerkleLim1Invalid);
        }
        if !merkle_verify_leaf(
            &rec.root,
            &ch.lj,
            &obex_primitives::MerklePath {
                siblings: ch.pj.siblings.clone(),
                index: j,
            },
        ) {
            return Err(VerifyErr::MerkleLjInvalid);
        }
        if !merkle_verify_leaf(
            &rec.root,
            &ch.lk,
            &obex_primitives::MerklePath {
                siblings: ch.pk_.siblings.clone(),
                index: k,
            },
        ) {
            return Err(VerifyErr::MerkleLkInvalid);
        }
        let li_check = label_update(&rec.seed, i, &ch.lim1, &ch.lj, &ch.lk);
        if !ct_eq_hash(&li_check, &ch.li) {
            return Err(VerifyErr::LabelEquationMismatch);
        }
    }
    Ok(())
}

#[must_use]
pub fn obex_verify_partrec(
    rec: &ObexPartRec,
    slot: u64,
    parent_id: &Hash256,
    vrf: &impl EcVrfVerifier,
) -> bool {
    obex_check_partrec(rec, slot, parent_id, vrf).is_ok()
}

pub fn build_participation_set<'a>(
    slot: u64,
    parent_id: &Hash256,
    submissions: impl Iterator<Item = &'a ObexPartRec>,
    vrf: &impl EcVrfVerifier,
) -> (Vec<Pk32>, Hash256) {
    use std::collections::BTreeSet;
    let mut seen: BTreeSet<Pk32> = BTreeSet::new();
    let mut pks: Vec<Pk32> = Vec::new();
    for rec in submissions {
        if rec.slot != slot {
            continue;
        }
        if seen.contains(&rec.pk_ed25519) {
            continue;
        }
        if obex_verify_partrec(rec, slot, parent_id, vrf) {
            seen.insert(rec.pk_ed25519);
            pks.push(rec.pk_ed25519);
        }
    }
    pks.sort_unstable();
    let leaves: Vec<Vec<u8>> = pks
        .iter()
        .map(|pk| {
            let mut b = Vec::with_capacity(64);
            b.extend_from_slice(&h_tag(constants::TAG_PART_LEAF, &[]));
            b.extend_from_slice(pk);
            b
        })
        .collect();
    let part_root = merkle_root(&leaves);
    (pks, part_root)
}

#[derive(Debug, Error)]
pub enum CodecError {
    #[error("input too short")]
    Short,
    #[error("trailing bytes after decode")]
    Trailing,
    #[error("bad vector length")]
    BadLen,
    #[error("vrf_y must be 64 bytes")]
    BadVrfY,
    #[error("vrf_pi must be 80 bytes")]
    BadVrfPi,
    #[error("wrong challenges count")]
    BadChallenges,
}

fn read_exact<'a>(src: &mut &'a [u8], n: usize) -> Result<&'a [u8], CodecError> {
    if src.len() < n {
        return Err(CodecError::Short);
    }
    let (a, b) = src.split_at(n);
    *src = b;
    Ok(a)
}
fn read_u32(src: &mut &[u8]) -> Result<u32, CodecError> {
    let b = read_exact(src, 4)?;
    Ok(u32::from_le_bytes(b.try_into().unwrap()))
}
fn read_u64(src: &mut &[u8]) -> Result<u64, CodecError> {
    let b = read_exact(src, 8)?;
    Ok(u64::from_le_bytes(b.try_into().unwrap()))
}
fn read_hash(src: &mut &[u8]) -> Result<Hash256, CodecError> {
    let b = read_exact(src, 32)?;
    let mut h = [0u8; 32];
    h.copy_from_slice(b);
    Ok(h)
}
fn read_hash_vec(src: &mut &[u8]) -> Result<Vec<Hash256>, CodecError> {
    let n = read_u32(src)? as usize;
    let mut v = Vec::with_capacity(n);
    for _ in 0..n {
        v.push(read_hash(src)?);
    }
    Ok(v)
}

fn write_le<const W: usize>(out: &mut Vec<u8>, x: u128) {
    out.extend_from_slice(&le_bytes::<W>(x));
}
fn write_bytes(out: &mut Vec<u8>, b: &[u8]) {
    out.extend_from_slice(b);
}
fn write_hash(out: &mut Vec<u8>, h: &Hash256) {
    out.extend_from_slice(h);
}
fn encode_hash_vec(out: &mut Vec<u8>, v: &[Hash256]) {
    write_le::<4>(out, v.len() as u128);
    for h in v {
        write_hash(out, h);
    }
}

fn encode_challenge(out: &mut Vec<u8>, ch: &ChallengeOpen) {
    write_le::<8>(out, u128::from(ch.idx));
    write_hash(out, &ch.li);
    encode_hash_vec(out, &ch.pi.siblings);
    write_hash(out, &ch.lim1);
    encode_hash_vec(out, &ch.pim1.siblings);
    write_hash(out, &ch.lj);
    encode_hash_vec(out, &ch.pj.siblings);
    write_hash(out, &ch.lk);
    encode_hash_vec(out, &ch.pk_.siblings);
}

pub fn encode_partrec(rec: &ObexPartRec) -> Result<Vec<u8>, CodecError> {
    if rec.vrf_y.len() != 64 {
        return Err(CodecError::BadVrfY);
    }
    if rec.vrf_pi.len() != 80 {
        return Err(CodecError::BadVrfPi);
    }
    if rec.challenges.len() != CHALLENGES_Q {
        return Err(CodecError::BadChallenges);
    }
    let mut out = Vec::new();
    write_le::<4>(&mut out, u128::from(rec.version));
    write_le::<8>(&mut out, u128::from(rec.slot));
    write_bytes(&mut out, &rec.pk_ed25519);
    write_bytes(&mut out, &rec.vrf_pk);
    write_hash(&mut out, &rec.y_edge_prev);
    write_hash(&mut out, &rec.alpha);
    write_bytes(&mut out, &rec.vrf_y);
    write_bytes(&mut out, &rec.vrf_pi);
    write_hash(&mut out, &rec.seed);
    write_hash(&mut out, &rec.root);
    write_le::<4>(&mut out, rec.challenges.len() as u128);
    for ch in &rec.challenges {
        encode_challenge(&mut out, ch);
    }
    write_bytes(&mut out, &rec.sig);
    Ok(out)
}

pub fn decode_partrec(mut src: &[u8]) -> Result<ObexPartRec, CodecError> {
    let version = read_u32(&mut src)?;
    let slot = read_u64(&mut src)?;
    let pk_ed25519 = {
        let b = read_exact(&mut src, 32)?;
        let mut a = [0u8; 32];
        a.copy_from_slice(b);
        a
    };
    let vrf_pk = {
        let b = read_exact(&mut src, 32)?;
        let mut a = [0u8; 32];
        a.copy_from_slice(b);
        a
    };
    let y_edge_prev = read_hash(&mut src)?;
    let alpha = read_hash(&mut src)?;
    let vrf_y = {
        let b = read_exact(&mut src, 64)?;
        b.to_vec()
    };
    let vrf_pi = {
        let b = read_exact(&mut src, 80)?;
        b.to_vec()
    };
    let seed = read_hash(&mut src)?;
    let root = read_hash(&mut src)?;
    let n_ch = read_u32(&mut src)? as usize;
    if n_ch != CHALLENGES_Q {
        return Err(CodecError::BadChallenges);
    }
    let mut challenges = Vec::with_capacity(n_ch);
    for _ in 0..n_ch {
        let idx = read_u64(&mut src)?;
        let li = read_hash(&mut src)?;
        let pi = MerklePathLite {
            siblings: read_hash_vec(&mut src)?,
        };
        let lim1 = read_hash(&mut src)?;
        let pim1 = MerklePathLite {
            siblings: read_hash_vec(&mut src)?,
        };
        let lj = read_hash(&mut src)?;
        let pj = MerklePathLite {
            siblings: read_hash_vec(&mut src)?,
        };
        let lk = read_hash(&mut src)?;
        let pk_ = MerklePathLite {
            siblings: read_hash_vec(&mut src)?,
        };
        challenges.push(ChallengeOpen {
            idx,
            li,
            pi,
            lim1,
            pim1,
            lj,
            pj,
            lk,
            pk_,
        });
    }
    let sig = {
        let b = read_exact(&mut src, 64)?;
        let mut s = [0u8; 64];
        s.copy_from_slice(b);
        s
    };
    if !src.is_empty() {
        return Err(CodecError::Trailing);
    }
    Ok(ObexPartRec {
        version,
        slot,
        pk_ed25519,
        vrf_pk,
        y_edge_prev,
        alpha,
        vrf_y,
        vrf_pi,
        seed,
        root,
        challenges,
        sig,
    })
}

'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_i>tests>codec.rs
#![allow(unused)]
use obex_alpha_i::*;

#[test]
fn partrec_roundtrip_minimal() {
    let mut challenges = Vec::with_capacity(CHALLENGES_Q);
    for _ in 0..CHALLENGES_Q {
        challenges.push(ChallengeOpen {
            idx: 1,
            li: [9u8; 32],
            pi: MerklePathLite { siblings: vec![] },
            lim1: [10u8; 32],
            pim1: MerklePathLite { siblings: vec![] },
            lj: [11u8; 32],
            pj: MerklePathLite { siblings: vec![] },
            lk: [12u8; 32],
            pk_: MerklePathLite { siblings: vec![] },
        });
    }
    let rec = ObexPartRec {
        version: OBEX_ALPHA_I_VERSION,
        slot: 1,
        pk_ed25519: [1u8; 32],
        vrf_pk: [2u8; 32],
        y_edge_prev: [3u8; 32],
        alpha: [4u8; 32],
        vrf_y: vec![5u8; 64],
        vrf_pi: vec![6u8; 80],
        seed: [7u8; 32],
        root: [8u8; 32],
        challenges,
        sig: [13u8; 64],
    };
    let bytes = encode_partrec(&rec).expect("encode");
    assert!(bytes.len() <= MAX_PARTREC_SIZE);
    let dec = decode_partrec(&bytes).expect("decode");
    assert_eq!(dec.version, rec.version);
    let bytes2 = encode_partrec(&dec).expect("encode2");
    assert_eq!(bytes, bytes2);
}

'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_i>tests>fuzz_decode.rs
#![allow(unused)]
use obex_alpha_i::decode_partrec;
use proptest::prelude::*;

proptest! {
    #[test]
    fn fuzz_partrec_decode_does_not_panic(data in proptest::collection::vec(any::<u8>(), 0..700_000)) {
        let _ = decode_partrec(&data);
    }
}

'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_ii>Cargo.toml
[package]
name = "obex_alpha_ii"
version = "1.0.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[dependencies]
obex_primitives = { path = "../obex_primitives" }
thiserror = "1.0"

[dev-dependencies]
proptest = "1.4"
criterion = "0.5"

[[bench]]
name = "header_validate"
harness = false



'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_ii>benches>header_validate.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use obex_alpha_ii::{
    obex_header_id, validate_header, Header, PartRootProvider, TicketRootProvider, TxRootProvider,
    OBEX_ALPHA_II_VERSION,
};
use obex_primitives::{constants, h_tag, le_bytes, Hash256};

struct Zero;
impl TicketRootProvider for Zero {
    fn compute_ticket_root(&self, _s: u64) -> Hash256 {
        [0u8; 32]
    }
}
impl PartRootProvider for Zero {
    fn compute_part_root(&self, _s: u64) -> Hash256 {
        [0u8; 32]
    }
}
impl TxRootProvider for Zero {
    fn compute_txroot(&self, _s: u64) -> Hash256 {
        [0u8; 32]
    }
}

fn bench_validate_header(c: &mut Criterion) {
    let parent = Header {
        parent_id: [9u8; 32],
        slot: 7,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit: [1u8; 32],
        vdf_y_core: [2u8; 32],
        vdf_y_edge: h_tag(constants::TAG_VDF_EDGE, &[&[2u8; 32]]),
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root: [0u8; 32],
        part_root: [0u8; 32],
        txroot_prev: [0u8; 32],
    };
    let providers = Zero;
    let parent_id_hdr = obex_header_id(&parent);
    let s = parent.slot + 1;
    let seed_commit = h_tag(
        constants::TAG_SLOT_SEED,
        &[&parent_id_hdr, &le_bytes::<8>(u128::from(s))],
    );
    let h = Header {
        parent_id: parent_id_hdr,
        slot: s,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit,
        vdf_y_core: [5u8; 32],
        vdf_y_edge: h_tag(constants::TAG_VDF_EDGE, &[&[5u8; 32]]),
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root: [0u8; 32],
        part_root: [0u8; 32],
        txroot_prev: [0u8; 32],
    };
    c.bench_function("validate_header", |b| {
        b.iter(|| {
            let _ = validate_header(
                black_box(&h),
                black_box(&parent),
                &providers,
                &providers,
                &providers,
                OBEX_ALPHA_II_VERSION,
            )
            .unwrap();
        });
    });
}

criterion_group!(benches, bench_validate_header);
criterion_main!(benches);

'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_ii>src>lib.rs
#![forbid(unsafe_code)]
#![deny(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(
    clippy::module_name_repetitions,
    clippy::missing_errors_doc,
    clippy::missing_panics_doc,
    clippy::result_large_err
)]

//! α‑II — Deterministic Header Engine with Beacon v1 (hash‑edge adapter)

use obex_primitives::{constants, ct_eq_hash, h_tag, le_bytes, Hash256};
use thiserror::Error;

pub const OBEX_ALPHA_II_VERSION: u32 = 2;
pub const MAX_PI_LEN: usize = 1_048_576;
pub const MAX_ELL_LEN: usize = 65_536;

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Header {
    pub parent_id: Hash256,
    pub slot: u64,
    pub obex_version: u32,
    pub seed_commit: Hash256,
    pub vdf_y_core: Hash256,
    pub vdf_y_edge: Hash256,
    pub vdf_pi: Vec<u8>,
    pub vdf_ell: Vec<u8>,
    pub ticket_root: Hash256,
    pub part_root: Hash256,
    pub txroot_prev: Hash256,
}

#[must_use]
pub fn obex_header_id(h: &Header) -> Hash256 {
    h_tag(
        constants::TAG_HEADER_ID,
        &[
            &h.parent_id,
            &le_bytes::<8>(u128::from(h.slot)),
            &le_bytes::<4>(u128::from(h.obex_version)),
            &h.seed_commit,
            &h.vdf_y_core,
            &h.vdf_y_edge,
            &le_bytes::<4>(h.vdf_pi.len() as u128),
            &h.vdf_pi,
            &le_bytes::<4>(h.vdf_ell.len() as u128),
            &h.vdf_ell,
            &h.ticket_root,
            &h.part_root,
            &h.txroot_prev,
        ],
    )
}

#[derive(Debug, Error)]
pub enum CodecError {
    #[error("short input")]
    Short,
    #[error("trailing")]
    Trailing,
    #[error("size cap")]
    TooLong,
}

fn read_exact<'a>(src: &mut &'a [u8], n: usize) -> Result<&'a [u8], CodecError> {
    if src.len() < n {
        return Err(CodecError::Short);
    }
    let (a, b) = src.split_at(n);
    *src = b;
    Ok(a)
}

#[must_use]
pub fn serialize_header(h: &Header) -> Vec<u8> {
    let mut out = Vec::new();
    out.extend_from_slice(&h.parent_id);
    out.extend_from_slice(&le_bytes::<8>(u128::from(h.slot)));
    out.extend_from_slice(&le_bytes::<4>(u128::from(h.obex_version)));
    out.extend_from_slice(&h.seed_commit);
    out.extend_from_slice(&h.vdf_y_core);
    out.extend_from_slice(&h.vdf_y_edge);
    out.extend_from_slice(&le_bytes::<4>(h.vdf_pi.len() as u128));
    out.extend_from_slice(&h.vdf_pi);
    out.extend_from_slice(&le_bytes::<4>(h.vdf_ell.len() as u128));
    out.extend_from_slice(&h.vdf_ell);
    out.extend_from_slice(&h.ticket_root);
    out.extend_from_slice(&h.part_root);
    out.extend_from_slice(&h.txroot_prev);
    out
}

pub fn deserialize_header(mut src: &[u8]) -> Result<Header, CodecError> {
    let parent_id = {
        let b = read_exact(&mut src, 32)?;
        let mut a = [0u8; 32];
        a.copy_from_slice(b);
        a
    };
    let slot = u64::from_le_bytes(read_exact(&mut src, 8)?.try_into().unwrap());
    let obex_version = u32::from_le_bytes(read_exact(&mut src, 4)?.try_into().unwrap());
    let seed_commit = {
        let b = read_exact(&mut src, 32)?;
        let mut a = [0u8; 32];
        a.copy_from_slice(b);
        a
    };
    let vdf_y_core = {
        let b = read_exact(&mut src, 32)?;
        let mut a = [0u8; 32];
        a.copy_from_slice(b);
        a
    };
    let vdf_y_edge = {
        let b = read_exact(&mut src, 32)?;
        let mut a = [0u8; 32];
        a.copy_from_slice(b);
        a
    };
    let pi_len = u32::from_le_bytes(read_exact(&mut src, 4)?.try_into().unwrap()) as usize;
    if pi_len > MAX_PI_LEN {
        return Err(CodecError::TooLong);
    }
    let vdf_pi = read_exact(&mut src, pi_len)?.to_vec();
    let ell_len = u32::from_le_bytes(read_exact(&mut src, 4)?.try_into().unwrap()) as usize;
    if ell_len > MAX_ELL_LEN {
        return Err(CodecError::TooLong);
    }
    let vdf_ell = read_exact(&mut src, ell_len)?.to_vec();
    let ticket_root = {
        let b = read_exact(&mut src, 32)?;
        let mut a = [0u8; 32];
        a.copy_from_slice(b);
        a
    };
    let part_root = {
        let b = read_exact(&mut src, 32)?;
        let mut a = [0u8; 32];
        a.copy_from_slice(b);
        a
    };
    let txroot_prev = {
        let b = read_exact(&mut src, 32)?;
        let mut a = [0u8; 32];
        a.copy_from_slice(b);
        a
    };
    if !src.is_empty() {
        return Err(CodecError::Trailing);
    }
    Ok(Header {
        parent_id,
        slot,
        obex_version,
        seed_commit,
        vdf_y_core,
        vdf_y_edge,
        vdf_pi,
        vdf_ell,
        ticket_root,
        part_root,
        txroot_prev,
    })
}

pub trait TicketRootProvider {
    fn compute_ticket_root(&self, slot: u64) -> Hash256;
}
pub trait PartRootProvider {
    fn compute_part_root(&self, slot: u64) -> Hash256;
}
pub trait TxRootProvider {
    fn compute_txroot(&self, slot: u64) -> Hash256;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ValidateErr {
    BadParentLink,
    BadSlot,
    VersionMismatch,
    VdfPiTooBig,
    VdfEllTooBig,
    BadSeedCommit,
    BeaconInvalid,
    TicketRootMismatch,
    PartRootMismatch,
    TxRootPrevMismatch,
}

pub fn validate_header(
    h: &Header,
    parent: &Header,
    tickets: &impl TicketRootProvider,
    parts: &impl PartRootProvider,
    txs: &impl TxRootProvider,
    expected_version: u32,
) -> Result<(), ValidateErr> {
    let parent_id_expected = obex_header_id(parent);
    if !ct_eq_hash(&h.parent_id, &parent_id_expected) {
        return Err(ValidateErr::BadParentLink);
    }
    if h.slot != parent.slot + 1 {
        return Err(ValidateErr::BadSlot);
    }
    if h.obex_version != expected_version {
        return Err(ValidateErr::VersionMismatch);
    }
    if h.vdf_pi.len() > MAX_PI_LEN {
        return Err(ValidateErr::VdfPiTooBig);
    }
    if h.vdf_ell.len() > MAX_ELL_LEN {
        return Err(ValidateErr::VdfEllTooBig);
    }
    // seed_commit equality
    let seed_commit_local = h_tag(
        constants::TAG_SLOT_SEED,
        &[&h.parent_id, &le_bytes::<8>(u128::from(h.slot))],
    );
    if !ct_eq_hash(&h.seed_commit, &seed_commit_local) {
        return Err(ValidateErr::BadSeedCommit);
    }
    // Beacon v1: pi/ell empty and edge = H(edge, [core])
    if !(h.vdf_pi.is_empty() && h.vdf_ell.is_empty()) {
        return Err(ValidateErr::BeaconInvalid);
    }
    let edge_check = h_tag(constants::TAG_VDF_EDGE, &[&h.vdf_y_core]);
    if !ct_eq_hash(&edge_check, &h.vdf_y_edge) {
        return Err(ValidateErr::BeaconInvalid);
    }
    // roots
    let ticket_root_local = tickets.compute_ticket_root(h.slot);
    if !ct_eq_hash(&h.ticket_root, &ticket_root_local) {
        return Err(ValidateErr::TicketRootMismatch);
    }
    let part_root_local = parts.compute_part_root(h.slot);
    if !ct_eq_hash(&h.part_root, &part_root_local) {
        return Err(ValidateErr::PartRootMismatch);
    }
    let txroot_prev_local = txs.compute_txroot(parent.slot);
    if !ct_eq_hash(&h.txroot_prev, &txroot_prev_local) {
        return Err(ValidateErr::TxRootPrevMismatch);
    }
    Ok(())
}

'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_ii>tests>fuzz_header_decode.rs
#![allow(unused)]
use obex_alpha_ii::deserialize_header;
use proptest::prelude::*;

proptest! {
    #[test]
    fn fuzz_header_decode_does_not_panic(data in proptest::collection::vec(any::<u8>(), 0..10_000)) {
        let _ = deserialize_header(&data);
    }
}

'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_ii>tests>negatives.rs
#![allow(unused)]
use obex_alpha_ii::*;
use obex_primitives::{constants, h_tag, le_bytes, Hash256};

struct Zero;
impl TicketRootProvider for Zero {
    fn compute_ticket_root(&self, _s: u64) -> Hash256 {
        [0u8; 32]
    }
}
impl PartRootProvider for Zero {
    fn compute_part_root(&self, _s: u64) -> Hash256 {
        [0u8; 32]
    }
}
impl TxRootProvider for Zero {
    fn compute_txroot(&self, _s: u64) -> Hash256 {
        [0u8; 32]
    }
}

fn mk_parent() -> Header {
    Header {
        parent_id: [9u8; 32],
        slot: 7,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit: [1u8; 32],
        vdf_y_core: [2u8; 32],
        vdf_y_edge: h_tag(constants::TAG_VDF_EDGE, &[&[2u8; 32]]),
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root: [0u8; 32],
        part_root: [0u8; 32],
        txroot_prev: [0u8; 32],
    }
}

#[test]
fn beacon_v1_edge_mismatch_rejected() {
    let parent = mk_parent();
    let providers = Zero;
    let parent_id_hdr = obex_header_id(&parent);
    let s = parent.slot + 1;
    let seed_commit = h_tag(
        constants::TAG_SLOT_SEED,
        &[&parent_id_hdr, &le_bytes::<8>(u128::from(s))],
    );
    let y_core = [5u8; 32];
    let y_edge_wrong = [6u8; 32];
    let h = Header {
        parent_id: parent_id_hdr,
        slot: s,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit,
        vdf_y_core: y_core,
        vdf_y_edge: y_edge_wrong,
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root: [0u8; 32],
        part_root: [0u8; 32],
        txroot_prev: [0u8; 32],
    };
    let err = validate_header(
        &h,
        &parent,
        &providers,
        &providers,
        &providers,
        OBEX_ALPHA_II_VERSION,
    )
    .unwrap_err();
    assert!(matches!(err, ValidateErr::BeaconInvalid));
}

#[test]
fn beacon_v1_nonempty_proofs_rejected() {
    let parent = mk_parent();
    let providers = Zero;
    let parent_id_hdr = obex_header_id(&parent);
    let s = parent.slot + 1;
    let seed_commit = h_tag(
        constants::TAG_SLOT_SEED,
        &[&parent_id_hdr, &le_bytes::<8>(u128::from(s))],
    );
    let y_core = [5u8; 32];
    let y_edge = h_tag(constants::TAG_VDF_EDGE, &[&y_core]);
    let h = Header {
        parent_id: parent_id_hdr,
        slot: s,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit,
        vdf_y_core: y_core,
        vdf_y_edge: y_edge,
        vdf_pi: vec![1, 2, 3],
        vdf_ell: vec![],
        ticket_root: [0u8; 32],
        part_root: [0u8; 32],
        txroot_prev: [0u8; 32],
    };
    let err = validate_header(
        &h,
        &parent,
        &providers,
        &providers,
        &providers,
        OBEX_ALPHA_II_VERSION,
    )
    .unwrap_err();
    assert!(matches!(
        err,
        ValidateErr::BeaconInvalid | ValidateErr::VdfPiTooBig
    ));
}

'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_iii>Cargo.toml
[package]
name = "obex_alpha_iii"
version = "1.0.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[dependencies]
obex_primitives = { path = "../obex_primitives" }
ed25519-dalek = { version = "2.1", default-features = false, features = ["pkcs8"] }



'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_iii>src>lib.rs
#![forbid(unsafe_code)]
#![deny(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(
    clippy::module_name_repetitions,
    clippy::missing_errors_doc,
    clippy::missing_panics_doc,
    clippy::result_large_err
)]

//! α‑III — Admission Engine (canonical tx bytes, fees, TicketRecord, root)

use ed25519_dalek::{Signature, VerifyingKey};
use obex_primitives::{constants, h_tag, le_bytes, merkle_root, Hash256};

pub type Pk32 = [u8; 32];
pub type Sig64 = [u8; 64];

pub const OBEX_ALPHA_III_VERSION: u32 = 1;
pub const MIN_TX_U: u128 = 10;
pub const FLAT_SWITCH_U: u128 = 1_000;
pub const FLAT_FEE_U: u128 = 10;

#[must_use]
pub fn fee_int(amount_u: u128) -> u128 {
    assert!(amount_u >= MIN_TX_U);
    if amount_u <= FLAT_SWITCH_U {
        FLAT_FEE_U
    } else {
        amount_u.div_ceil(100)
    }
}

#[derive(Clone, Default, Debug, PartialEq, Eq)]
pub struct AccessList {
    pub read_accounts: Vec<Pk32>,
    pub write_accounts: Vec<Pk32>,
}

fn sort_dedup(mut v: Vec<Pk32>) -> Vec<Pk32> {
    v.sort_unstable();
    v.dedup();
    v
}

#[must_use]
pub fn encode_access(a: &AccessList) -> Vec<u8> {
    let r = sort_dedup(a.read_accounts.clone());
    let w = sort_dedup(a.write_accounts.clone());
    let mut out = Vec::new();
    out.extend_from_slice(&h_tag(constants::TAG_TX_ACCESS, &[]));
    out.extend_from_slice(&le_bytes::<4>(r.len() as u128));
    for pk in &r {
        out.extend_from_slice(pk);
    }
    out.extend_from_slice(&le_bytes::<4>(w.len() as u128));
    for pk in &w {
        out.extend_from_slice(pk);
    }
    out
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct TxBodyV1 {
    pub sender: Pk32,
    pub recipient: Pk32,
    pub nonce: u64,
    pub amount_u: u128,
    pub fee_u: u128,
    pub s_bind: u64,
    pub y_bind: Hash256,
    pub access: AccessList,
    pub memo: Vec<u8>,
}

#[must_use]
pub fn canonical_tx_bytes(tx: &TxBodyV1) -> Vec<u8> {
    let mut out = Vec::new();
    out.extend_from_slice(&h_tag(constants::TAG_TX_BODY_V1, &[]));
    out.extend_from_slice(&tx.sender);
    out.extend_from_slice(&tx.recipient);
    out.extend_from_slice(&le_bytes::<8>(u128::from(tx.nonce)));
    out.extend_from_slice(&le_bytes::<16>(tx.amount_u));
    out.extend_from_slice(&le_bytes::<16>(tx.fee_u));
    out.extend_from_slice(&le_bytes::<8>(u128::from(tx.s_bind)));
    out.extend_from_slice(&tx.y_bind);
    out.extend_from_slice(&encode_access(&tx.access));
    out.extend_from_slice(&le_bytes::<4>(tx.memo.len() as u128));
    out.extend_from_slice(&tx.memo);
    out
}

#[must_use]
pub fn txid(tx: &TxBodyV1) -> Hash256 {
    h_tag(constants::TAG_TX_ID, &[&canonical_tx_bytes(tx)])
}
#[must_use]
pub fn tx_commit(tx: &TxBodyV1) -> Hash256 {
    h_tag(constants::TAG_TX_COMMIT, &[&canonical_tx_bytes(tx)])
}

#[must_use]
fn verify_sig(pk: &Pk32, msg: &[u8], sig: &Sig64) -> bool {
    match (VerifyingKey::from_bytes(pk), Signature::from_slice(sig)) {
        (Ok(vk), Ok(sig_d)) => vk.verify_strict(msg, &sig_d).is_ok(),
        _ => false,
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct TicketRecord {
    pub ticket_id: Hash256,
    pub txid: Hash256,
    pub sender: Pk32,
    pub nonce: u64,
    pub amount_u: u128,
    pub fee_u: u128,
    pub s_admit: u64,
    pub s_exec: u64,
    pub commit_hash: Hash256,
}

#[must_use]
pub fn enc_ticket_leaf(t: &TicketRecord) -> Vec<u8> {
    let mut out = Vec::new();
    out.extend_from_slice(&h_tag(constants::TAG_TICKET_LEAF, &[]));
    out.extend_from_slice(&t.ticket_id);
    out.extend_from_slice(&t.txid);
    out.extend_from_slice(&t.sender);
    out.extend_from_slice(&le_bytes::<8>(u128::from(t.nonce)));
    out.extend_from_slice(&le_bytes::<16>(t.amount_u));
    out.extend_from_slice(&le_bytes::<16>(t.fee_u));
    out.extend_from_slice(&le_bytes::<8>(u128::from(t.s_admit)));
    out.extend_from_slice(&le_bytes::<8>(u128::from(t.s_exec)));
    out.extend_from_slice(&t.commit_hash);
    out
}

#[derive(Default, Clone, Debug, PartialEq, Eq)]
pub struct AlphaIIIState {
    pub spendable_u: std::collections::BTreeMap<Pk32, u128>,
    pub reserved_u: std::collections::BTreeMap<Pk32, u128>,
    pub next_nonce: std::collections::BTreeMap<Pk32, u64>,
    pub admitted_by_slot: std::collections::BTreeMap<u64, Vec<TicketRecord>>,
    pub tickets_by_txid: std::collections::BTreeMap<Hash256, TicketRecord>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AdmitErr {
    BadSig,
    WrongSlot,
    WrongBeacon,
    NonceMismatch,
    BelowMinAmount,
    FeeMismatch,
    InsufficientFunds,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AdmitResult {
    Finalized(TicketRecord),
    Rejected(AdmitErr),
}

pub fn admit_single(
    tx: &TxBodyV1,
    sig: &Sig64,
    s_now: u64,
    y_prev: &Hash256,
    st: &mut AlphaIIIState,
) -> AdmitResult {
    let msg = h_tag(constants::TAG_TX_SIG, &[&canonical_tx_bytes(tx)]);
    if !verify_sig(&tx.sender, &msg, sig) {
        return AdmitResult::Rejected(AdmitErr::BadSig);
    }
    if tx.s_bind != s_now {
        return AdmitResult::Rejected(AdmitErr::WrongSlot);
    }
    if tx.y_bind != *y_prev {
        return AdmitResult::Rejected(AdmitErr::WrongBeacon);
    }
    if tx.nonce != *st.next_nonce.get(&tx.sender).unwrap_or(&0) {
        return AdmitResult::Rejected(AdmitErr::NonceMismatch);
    }
    if tx.amount_u < MIN_TX_U {
        return AdmitResult::Rejected(AdmitErr::BelowMinAmount);
    }
    if tx.fee_u != fee_int(tx.amount_u) {
        return AdmitResult::Rejected(AdmitErr::FeeMismatch);
    }
    let total = tx.amount_u.saturating_add(tx.fee_u);
    if st.spendable_u.get(&tx.sender).copied().unwrap_or(0) < total {
        return AdmitResult::Rejected(AdmitErr::InsufficientFunds);
    }

    *st.spendable_u.entry(tx.sender).or_insert(0) -= total;
    *st.reserved_u.entry(tx.sender).or_insert(0) += total;
    *st.next_nonce.entry(tx.sender).or_insert(0) += 1;

    let xid = txid(tx);
    let rec = TicketRecord {
        ticket_id: h_tag(
            constants::TAG_TICKET_ID,
            &[&xid, &le_bytes::<8>(u128::from(s_now))],
        ),
        txid: xid,
        sender: tx.sender,
        nonce: tx.nonce,
        amount_u: tx.amount_u,
        fee_u: tx.fee_u,
        s_admit: s_now,
        s_exec: s_now,
        commit_hash: tx_commit(tx),
    };
    st.admitted_by_slot
        .entry(s_now)
        .or_default()
        .push(rec.clone());
    st.tickets_by_txid.insert(rec.txid, rec.clone());
    AdmitResult::Finalized(rec)
}

#[must_use]
pub fn build_ticket_root_for_slot(s: u64, st: &AlphaIIIState) -> (Vec<Vec<u8>>, Hash256) {
    let mut list = st.admitted_by_slot.get(&s).cloned().unwrap_or_default();
    list.sort_by(|a, b| a.txid.cmp(&b.txid));
    let leaves: Vec<Vec<u8>> = list.iter().map(enc_ticket_leaf).collect();
    let root = merkle_root(&leaves);
    (leaves, root)
}

'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_iii>tests>admission.rs
#![allow(unused)]
use obex_alpha_iii::*;

fn pk(v: u8) -> [u8; 32] {
    [v; 32]
}

#[test]
fn fee_rule_edges() {
    assert_eq!(fee_int(10), FLAT_FEE_U);
    assert_eq!(fee_int(1_000), FLAT_FEE_U);
    assert_eq!(fee_int(1_001), 11);
}

#[test]
fn admit_rejects_bad_sig_and_wrong_bindings() {
    let mut st = AlphaIIIState::default();
    st.spendable_u.insert(pk(1), 10_000);
    let tx = TxBodyV1 {
        sender: pk(1),
        recipient: pk(2),
        nonce: 0,
        amount_u: 2_000,
        fee_u: fee_int(2_000),
        s_bind: 5,
        y_bind: [7u8; 32],
        access: AccessList::default(),
        memo: vec![],
    };
    // bad sig
    let bad = admit_single(&tx, &[0u8; 64], 5, &tx.y_bind, &mut st);
    assert!(matches!(
        bad,
        AdmitResult::Rejected(AdmitErr::BadSig) | AdmitResult::Rejected(_)
    ));
}

#[test]
fn ticket_leaf_length_is_216_bytes() {
    let rec = TicketRecord {
        ticket_id: [0u8; 32],
        txid: [1u8; 32],
        sender: [2u8; 32],
        nonce: 0,
        amount_u: 1000,
        fee_u: 10,
        s_admit: 1,
        s_exec: 1,
        commit_hash: [3u8; 32],
    };
    let leaf = enc_ticket_leaf(&rec);
    assert_eq!(leaf.len(), 216);
}

'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_t>Cargo.toml
[package]
name = "obex_alpha_t"
version = "1.0.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[dependencies]
obex_primitives = { path = "../obex_primitives" }
primitive-types = "0.12.2"
thiserror = "1.0"



'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_t>src>lib.rs
#![forbid(unsafe_code)]
#![deny(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(
    clippy::module_name_repetitions,
    clippy::missing_errors_doc,
    clippy::missing_panics_doc,
    clippy::result_large_err
)]

//! α‑T — Tokenomics (emission, NLB fee splits, DRP, sys tx ordering)

use obex_primitives::{constants, h_tag, Hash256};
use primitive_types::U256;
use std::sync::LazyLock as Lazy;

pub const OBEX_ALPHA_T_VERSION: u32 = 1;
pub const UOBX_PER_OBX: u128 = 100_000_000;
pub const TOTAL_SUPPLY_OBX: u128 = 1_000_000;
pub const TOTAL_SUPPLY_UOBX: u128 = TOTAL_SUPPLY_OBX * UOBX_PER_OBX;

pub const SLOT_MS: u64 = 100;
pub const SLOTS_PER_SEC: u64 = 1_000 / SLOT_MS;
pub const PROTOCOL_YEAR_SEC: u64 = 365 * 86_400;
pub const SLOTS_PER_YEAR: u64 = PROTOCOL_YEAR_SEC * SLOTS_PER_SEC;
pub const YEARS_PER_HALVING: u64 = 5;
pub const SLOTS_PER_HALVING: u128 = (SLOTS_PER_YEAR as u128) * (YEARS_PER_HALVING as u128);
pub const HALVING_COUNT: u32 = 20;
pub const LAST_EMISSION_SLOT: u128 = (SLOTS_PER_YEAR as u128) * 100;

fn pow2_u256(n: u32) -> U256 {
    U256::from(1u8) << n
}
static TWO_POW_N_MINUS1: Lazy<U256> = Lazy::new(|| pow2_u256(HALVING_COUNT - 1));
static TWO_POW_N: Lazy<U256> = Lazy::new(|| pow2_u256(HALVING_COUNT));
static R0_NUM: Lazy<U256> = Lazy::new(|| U256::from(TOTAL_SUPPLY_UOBX) * *TWO_POW_N_MINUS1);
static R0_DEN: Lazy<U256> =
    Lazy::new(|| U256::from(SLOTS_PER_HALVING) * (*TWO_POW_N - U256::from(1u8)));

#[derive(Clone, Default, Debug, PartialEq, Eq)]
pub struct EmissionState {
    pub total_emitted_u: u128,
    pub acc_num: U256,
}

#[inline]
fn period_index(slot_1based: u128) -> u32 {
    let periods = (slot_1based - 1) / SLOTS_PER_HALVING;
    u32::try_from(periods).expect("period index overflow")
}

fn reward_den_for_period(p: u32) -> U256 {
    *R0_DEN * pow2_u256(p)
}

pub fn on_slot_emission(
    st: &mut EmissionState,
    slot_1based: u128,
    mut credit_emission: impl FnMut(u128),
) {
    if slot_1based == 0 || slot_1based > LAST_EMISSION_SLOT {
        return;
    }
    let p = period_index(slot_1based);
    let den = reward_den_for_period(p);
    st.acc_num += *R0_NUM;
    let payout_u256 = st.acc_num / den;
    if payout_u256 > U256::zero() {
        let payout = payout_u256.as_u128();
        let remaining = TOTAL_SUPPLY_UOBX - st.total_emitted_u;
        let pay = payout.min(remaining);
        if pay > 0 {
            credit_emission(pay);
            st.total_emitted_u = st.total_emitted_u.saturating_add(pay);
            st.acc_num -= U256::from(pay) * den;
        }
    }
    if slot_1based == LAST_EMISSION_SLOT {
        let remaining = TOTAL_SUPPLY_UOBX.saturating_sub(st.total_emitted_u);
        if remaining > 0 {
            credit_emission(remaining);
            st.total_emitted_u = TOTAL_SUPPLY_UOBX;
            st.acc_num = U256::zero();
        }
        assert!(st.total_emitted_u == TOTAL_SUPPLY_UOBX);
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum SysTxKind {
    EscrowCredit,
    VerifierCredit,
    TreasuryCredit,
    Burn,
    RewardPayout,
    EmissionCredit,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct SysTx {
    pub kind: SysTxKind,
    pub slot: u64,
    pub pk: Hash256,
    pub amt: u128,
}

#[must_use]
fn reward_rank(y: &Hash256, pk: &Hash256) -> Hash256 {
    h_tag(constants::TAG_REWARD_RANK, &[y, pk])
}

#[must_use]
pub fn canonical_sys_tx_order(sys_txs: Vec<SysTx>, y_edge_s: &Hash256) -> Vec<SysTx> {
    let mut rewards: Vec<SysTx> = sys_txs
        .iter()
        .copied()
        .filter(|t| matches!(t.kind, SysTxKind::RewardPayout))
        .collect();
    let mut others: Vec<SysTx> = sys_txs
        .into_iter()
        .filter(|t| !matches!(t.kind, SysTxKind::RewardPayout))
        .collect();
    others.sort_by_key(|tx| match tx.kind {
        SysTxKind::EscrowCredit => 0,
        SysTxKind::EmissionCredit => 1,
        SysTxKind::VerifierCredit => 2,
        SysTxKind::TreasuryCredit => 3,
        SysTxKind::Burn => 4,
        SysTxKind::RewardPayout => 5,
    });
    rewards.sort_by(|a, b| reward_rank(y_edge_s, &a.pk).cmp(&reward_rank(y_edge_s, &b.pk)));
    others.extend(rewards);
    others
}

'PROJECT_ROOT'>obex-alpha>crates>obex_alpha_t>tests>tokenomics.rs
#![allow(unused)]
use obex_alpha_t::*;

#[test]
fn emission_monotone_and_terminal_flush() {
    let mut st = EmissionState::default();
    let mut last = 0u128;
    for s in 1u128..=1_000 {
        on_slot_emission(&mut st, s, |_| {});
        assert!(st.total_emitted_u >= last);
        last = st.total_emitted_u;
    }
    on_slot_emission(&mut st, LAST_EMISSION_SLOT, |_| {});
    assert_eq!(st.total_emitted_u, TOTAL_SUPPLY_UOBX);
}

#[test]
fn sys_tx_ordering_canonical() {
    let y = [0u8; 32];
    let mut txs = vec![
        SysTx {
            kind: SysTxKind::Burn,
            slot: 1,
            pk: [1u8; 32],
            amt: 5,
        },
        SysTx {
            kind: SysTxKind::RewardPayout,
            slot: 1,
            pk: [2u8; 32],
            amt: 7,
        },
        SysTx {
            kind: SysTxKind::EscrowCredit,
            slot: 1,
            pk: [3u8; 32],
            amt: 9,
        },
        SysTx {
            kind: SysTxKind::VerifierCredit,
            slot: 1,
            pk: [4u8; 32],
            amt: 2,
        },
        SysTx {
            kind: SysTxKind::TreasuryCredit,
            slot: 1,
            pk: [5u8; 32],
            amt: 3,
        },
        SysTx {
            kind: SysTxKind::EmissionCredit,
            slot: 1,
            pk: [6u8; 32],
            amt: 11,
        },
        SysTx {
            kind: SysTxKind::RewardPayout,
            slot: 1,
            pk: [7u8; 32],
            amt: 13,
        },
    ];
    let ordered = canonical_sys_tx_order(std::mem::take(&mut txs), &y);
    assert!(matches!(ordered[0].kind, SysTxKind::EscrowCredit));
    assert!(matches!(ordered[1].kind, SysTxKind::EmissionCredit));
    assert!(matches!(ordered[2].kind, SysTxKind::VerifierCredit));
    assert!(matches!(ordered[3].kind, SysTxKind::TreasuryCredit));
    assert!(matches!(ordered[4].kind, SysTxKind::Burn));
    assert!(matches!(ordered[5].kind, SysTxKind::RewardPayout));
}

'PROJECT_ROOT'>obex-alpha>crates>obex_node>Cargo.toml
[package]
name = "obex_node"
version = "1.0.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[dependencies]
obex_primitives = { path = "../obex_primitives" }
obex_alpha_i = { path = "../obex_alpha_i" }
obex_alpha_ii = { path = "../obex_alpha_ii" }
obex_alpha_iii = { path = "../obex_alpha_iii" }
obex_alpha_t = { path = "../obex_alpha_t" }
tokio = { version = "1.37", features = ["rt-multi-thread", "macros"] }
axum = "0.7"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
toml = "0.8"
thiserror = "1.0"
anyhow = "1.0"
hex = "0.4"
sha2 = "0.10"
vrf-rfc9381 = { version = "0.0.3", features = ["ec", "edwards25519"] }
sled = "0.34"
futures = "0.3"
clap = { version = "4.5", features = ["derive"] }
reqwest = { version = "0.12", features = ["json", "rustls-tls"] }
subtle = "2.6"



'PROJECT_ROOT'>obex-alpha>crates>obex_node>src>main.rs
#![forbid(unsafe_code)]
#![deny(warnings)]

use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::{IntoResponse, Response},
    routing::{get, post},
    Json, Router,
};
use clap::Parser;
use subtle::ConstantTimeEq;
// use serde_json::json; // reserved for structured logs when puller is added
use hex::FromHex;
use obex_alpha_i::{decode_partrec, obex_verify_partrec, EcVrfVerifier, MAX_PARTREC_SIZE};
use obex_alpha_ii::{
    deserialize_header, obex_header_id, serialize_header, validate_header, Header,
    PartRootProvider, TicketRootProvider, TxRootProvider, OBEX_ALPHA_II_VERSION,
};
use obex_primitives::{constants, h_tag, le_bytes, merkle_root, Hash256};
use std::{
    collections::HashMap,
    net::SocketAddr,
    sync::{atomic::{AtomicU64, Ordering}, Arc},
    time::{Duration, Instant, SystemTime, UNIX_EPOCH},
};
use tokio::sync::{RwLock, Semaphore};
type Db = sled::Db;

#[derive(Clone)]
#[allow(dead_code)]
struct AppState {
    // (slot, pk32) -> canonical ObexPartRec bytes
    partrecs: Arc<RwLock<HashMap<(u64, [u8; 32]), Vec<u8>>>>,
    // slot -> Vec<ticket leaf bytes>
    ticket_leaves: Arc<RwLock<HashMap<u64, Vec<Vec<u8>>>>>,
    // headers by slot
    headers: Arc<RwLock<HashMap<u64, Header>>>,
    db: Arc<Db>,
    metrics: Arc<Metrics>,
    sem_partrec: Arc<Semaphore>,
    sem_tickets: Arc<Semaphore>,
    peers: Arc<Vec<String>>,
    http_timeout_ms: u64,
}

const MAX_CONCURRENT_PARTREC_INGEST: usize = 16;
const MAX_CONCURRENT_TICKETS_INGEST: usize = 8;

struct Metrics {
    headers_validated_total: AtomicU64,
    headers_rejected_total: AtomicU64,
    header_validate_ms_total: AtomicU64,
    header_validate_count: AtomicU64,

    alpha_i_verify_ms_total: AtomicU64,
    alpha_i_verify_count: AtomicU64,

    root_build_ms_total: AtomicU64,
    root_build_count: AtomicU64,
    fetch_success_total: AtomicU64,
    fetch_fail_total: AtomicU64,
}

impl Metrics {
    fn new() -> Self {
        Self {
            headers_validated_total: AtomicU64::new(0),
            headers_rejected_total: AtomicU64::new(0),
            header_validate_ms_total: AtomicU64::new(0),
            header_validate_count: AtomicU64::new(0),
            alpha_i_verify_ms_total: AtomicU64::new(0),
            alpha_i_verify_count: AtomicU64::new(0),
            root_build_ms_total: AtomicU64::new(0),
            root_build_count: AtomicU64::new(0),
            fetch_success_total: AtomicU64::new(0),
            fetch_fail_total: AtomicU64::new(0),
        }
    }
}

fn metrics_text(m: &Metrics) -> String {
    let hv = m.headers_validated_total.load(Ordering::Relaxed);
    let hr = m.headers_rejected_total.load(Ordering::Relaxed);
    let hv_ms = m.header_validate_ms_total.load(Ordering::Relaxed);
    let hv_cnt = m.header_validate_count.load(Ordering::Relaxed);
    let hv_avg = if hv_cnt == 0 { 0 } else { hv_ms / hv_cnt };

    let ai_ms = m.alpha_i_verify_ms_total.load(Ordering::Relaxed);
    let ai_cnt = m.alpha_i_verify_count.load(Ordering::Relaxed);
    let ai_avg = if ai_cnt == 0 { 0 } else { ai_ms / ai_cnt };

    let rb_ms = m.root_build_ms_total.load(Ordering::Relaxed);
    let rb_cnt = m.root_build_count.load(Ordering::Relaxed);
    let rb_avg = if rb_cnt == 0 { 0 } else { rb_ms / rb_cnt };
    let fsucc = m.fetch_success_total.load(Ordering::Relaxed);
    let ffail = m.fetch_fail_total.load(Ordering::Relaxed);

    format!(
        "# HELP obex_node_up 1\n# TYPE obex_node_up gauge\nobex_node_up 1\n\
         # HELP headers_validated_total count\n# TYPE headers_validated_total counter\nheaders_validated_total {}\n\
         # HELP headers_rejected_total count\n# TYPE headers_rejected_total counter\nheaders_rejected_total {}\n\
         # HELP header_validate_avg_ms average\n# TYPE header_validate_avg_ms gauge\nheader_validate_avg_ms {}\n\
         # HELP alpha_i_verify_avg_ms average\n# TYPE alpha_i_verify_avg_ms gauge\nalpha_i_verify_avg_ms {}\n\
         # HELP root_build_avg_ms average\n# TYPE root_build_avg_ms gauge\nroot_build_avg_ms {}\n\
         # HELP fetch_success_total count\n# TYPE fetch_success_total counter\nfetch_success_total {}\n\
         # HELP fetch_fail_total count\n# TYPE fetch_fail_total counter\nfetch_fail_total {}\n",
        hv, hr, hv_avg, ai_avg, rb_avg, fsucc, ffail
    )
}

fn log_json(level: &str, code: u32, msg: &str, extra: serde_json::Value) {
    let ts = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis();
    let obj = serde_json::json!({
        "ts_ms": ts,
        "level": level,
        "code": code,
        "msg": msg,
        "extra": extra,
    });
    println!("{}", obj);
}

fn decode_pk_hex(s: &str) -> Result<[u8; 32], String> {
    if s.len() != 64 {
        return Err("pk hex must be 64 chars".to_owned());
    }
    let bytes = <[u8; 32]>::from_hex(s).map_err(|_| "invalid hex".to_owned())?;
    Ok(bytes)
}

async fn get_alpha_i_partrec(
    Path((slot, pk_hex)): Path<(u64, String)>,
    State(st): State<AppState>,
) -> Result<Response, (StatusCode, String)> {
    let pk = decode_pk_hex(&pk_hex).map_err(|e| (StatusCode::BAD_REQUEST, e))?;
    let map = st.partrecs.read().await;
    let key = (slot, pk);
    let Some(bytes) = map.get(&key) else {
        return Err((StatusCode::NOT_FOUND, "not found".to_owned()));
    };
    if bytes.len() > MAX_PARTREC_SIZE {
        return Err((
            StatusCode::PAYLOAD_TOO_LARGE,
            "partrec too large".to_owned(),
        ));
    }
    Ok((StatusCode::OK, bytes.clone()).into_response())
}

async fn get_alpha_iii_leaves(
    Path(slot): Path<u64>,
    State(st): State<AppState>,
) -> Result<Response, (StatusCode, String)> {
    let map = st.ticket_leaves.read().await;
    let Some(leaves) = map.get(&slot) else {
        return Err((StatusCode::NOT_FOUND, "not found".to_owned()));
    };
    let mut out = Vec::new();
    for leaf in leaves {
        out.extend_from_slice(leaf);
    }
    Ok((StatusCode::OK, out).into_response())
}

// POST /alpha_i/{slot}/{pk} — ingest canonical ObexPartRec bytes (size-capped and decodable)
async fn post_alpha_i_partrec(
    Path((slot, pk_hex)): Path<(u64, String)>,
    State(st): State<AppState>,
    body: axum::body::Bytes,
) -> Result<String, (StatusCode, String)> {
    let _permit = st
        .sem_partrec
        .acquire_owned()
        .await
        .map_err(|_| (StatusCode::SERVICE_UNAVAILABLE, "busy".to_owned()))?;
    let pk = decode_pk_hex(&pk_hex).map_err(|e| (StatusCode::BAD_REQUEST, e))?;
    let bytes = body.to_vec();
    if bytes.len() > MAX_PARTREC_SIZE {
        return Err((
            StatusCode::PAYLOAD_TOO_LARGE,
            "partrec too large".to_owned(),
        ));
    }
    let rec = decode_partrec(&bytes)
        .map_err(|_| (StatusCode::UNPROCESSABLE_ENTITY, "decode error".to_owned()))?;
    if rec.slot != slot {
        return Err((StatusCode::BAD_REQUEST, "slot mismatch".to_owned()));
    }
    // Persist
    st.partrecs.write().await.insert((slot, pk), bytes.clone());
    put_partrec_db(&st.db, slot, &pk, &bytes)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e))?;
    Ok("ok".to_owned())
}

// POST /alpha_iii/{slot} — ingest concatenated ticket leaves (216-byte leaf size)
async fn post_alpha_iii_leaves(
    Path(slot): Path<u64>,
    State(st): State<AppState>,
    body: axum::body::Bytes,
) -> Result<String, (StatusCode, String)> {
    let _permit = st
        .sem_tickets
        .acquire_owned()
        .await
        .map_err(|_| (StatusCode::SERVICE_UNAVAILABLE, "busy".to_owned()))?;
    const LEAF_LEN: usize = 216; // tag(32)+ticket_id(32)+txid(32)+sender(32)+nonce(8)+amount(16)+fee(16)+s_admit(8)+s_exec(8)+commit_hash(32)
    let buf = body.to_vec();
    if buf.len() % LEAF_LEN != 0 {
        return Err((
            StatusCode::BAD_REQUEST,
            "bad concatenation length".to_owned(),
        ));
    }
    let mut leaves: Vec<Vec<u8>> = Vec::with_capacity(buf.len() / LEAF_LEN);
    let mut i = 0;
    while i < buf.len() {
        leaves.push(buf[i..i + LEAF_LEN].to_vec());
        i += LEAF_LEN;
    }
    st.ticket_leaves.write().await.insert(slot, leaves.clone());
    put_ticket_leaves_db(&st.db, slot, &buf).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e))?;
    Ok("ok".to_owned())
}

fn router(state: AppState) -> Router {
    Router::new()
        .route(
            "/alpha_i/:slot/:pk",
            get(get_alpha_i_partrec).post(post_alpha_i_partrec),
        )
        .route(
            "/alpha_iii/:slot",
            get(get_alpha_iii_leaves).post(post_alpha_iii_leaves),
        )
        .route("/header/:slot", get(get_header))
        .route("/header", post(post_header))
        .route("/advance", post(post_advance))
        .route("/metrics", get(metrics))
        .route("/healthz", get(healthz))
        .with_state(state)
}

#[derive(Parser, Debug)]
#[command(name = "obex-node")]
#[command(about = "OBEX Alpha node (testnet)", long_about = None)]
struct Args {
    #[arg(long, default_value = "127.0.0.1:8080")]
    listen: String,
    #[arg(long, default_value = "data/obex-node")]
    data_dir: String,
    #[arg(long, value_delimiter = ',')]
    peers: Vec<String>,
    #[arg(long, default_value_t = MAX_CONCURRENT_PARTREC_INGEST)]
    max_partrec_concurrency: usize,
    #[arg(long, default_value_t = MAX_CONCURRENT_TICKETS_INGEST)]
    max_ticket_concurrency: usize,
    #[arg(long, default_value_t = 2000)]
    http_timeout_ms: u64,
}

#[tokio::main]
async fn main() {
    let args = Args::parse();
    let db = sled::open(&args.data_dir).expect("db");
    let db = Arc::new(db);
    let state = AppState {
        db: db.clone(),
        partrecs: Arc::new(RwLock::new(HashMap::new())),
        ticket_leaves: Arc::new(RwLock::new(HashMap::new())),
        headers: Arc::new(RwLock::new(HashMap::new())),
        metrics: Arc::new(Metrics::new()),
        sem_partrec: Arc::new(Semaphore::new(args.max_partrec_concurrency)),
        sem_tickets: Arc::new(Semaphore::new(args.max_ticket_concurrency)),
        peers: Arc::new(args.peers.clone()),
        http_timeout_ms: args.http_timeout_ms,
    };
    // Load persisted headers
    if let Ok(Some(h0)) = get_header_db(&db, 0) {
        state.headers.write().await.insert(0, h0);
    } else {
        // Initialize genesis header at slot 0
        let y_core = [0u8; 32];
        let y_edge = h_tag(constants::TAG_VDF_EDGE, &[&y_core]);
        let h0 = Header {
            parent_id: [0u8; 32],
            slot: 0,
            obex_version: OBEX_ALPHA_II_VERSION,
            seed_commit: h_tag(constants::TAG_SLOT_SEED, &[&[0u8; 32], &le_bytes::<8>(0)]),
            vdf_y_core: y_core,
            vdf_y_edge: y_edge,
            vdf_pi: vec![],
            vdf_ell: vec![],
            ticket_root: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
            part_root: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
            txroot_prev: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
        };
        put_header_db(&db, &h0).expect("persist genesis");
        state.headers.write().await.insert(0, h0);
    }
    let app = router(state);
    let addr: SocketAddr = args.listen.parse().unwrap();
    axum::serve(tokio::net::TcpListener::bind(addr).await.unwrap(), app)
        .await
        .unwrap();
}

// Header GET
async fn get_header(
    Path(slot): Path<u64>,
    State(st): State<AppState>,
) -> Result<Json<HeaderDto>, (StatusCode, String)> {
    let map = st.headers.read().await;
    let Some(h) = map.get(&slot) else {
        return Err((StatusCode::NOT_FOUND, "not found".to_owned()));
    };
    Ok(Json(HeaderDto::from_header(h)))
}

// Header POST (accepts JSON; validates against current store and computes equalities)
#[derive(serde::Deserialize, serde::Serialize, Clone)]
struct HeaderDto {
    parent_id: [u8; 32],
    slot: u64,
    obex_version: u32,
    seed_commit: [u8; 32],
    vdf_y_core: [u8; 32],
    vdf_y_edge: [u8; 32],
    vdf_pi: Vec<u8>,
    vdf_ell: Vec<u8>,
    ticket_root: [u8; 32],
    part_root: [u8; 32],
    txroot_prev: [u8; 32],
}

impl HeaderDto {
    fn into_header(self) -> Header {
        Header {
            parent_id: self.parent_id,
            slot: self.slot,
            obex_version: self.obex_version,
            seed_commit: self.seed_commit,
            vdf_y_core: self.vdf_y_core,
            vdf_y_edge: self.vdf_y_edge,
            vdf_pi: self.vdf_pi,
            vdf_ell: self.vdf_ell,
            ticket_root: self.ticket_root,
            part_root: self.part_root,
            txroot_prev: self.txroot_prev,
        }
    }
    fn from_header(h: &Header) -> Self {
        Self {
            parent_id: h.parent_id,
            slot: h.slot,
            obex_version: h.obex_version,
            seed_commit: h.seed_commit,
            vdf_y_core: h.vdf_y_core,
            vdf_y_edge: h.vdf_y_edge,
            vdf_pi: h.vdf_pi.clone(),
            vdf_ell: h.vdf_ell.clone(),
            ticket_root: h.ticket_root,
            part_root: h.part_root,
            txroot_prev: h.txroot_prev,
        }
    }
}

struct Providers<'a> {
    st: &'a AppState,
}
impl TicketRootProvider for Providers<'_> {
    fn compute_ticket_root(&self, slot: u64) -> Hash256 {
        futures::executor::block_on(ticket_root_for_slot(self.st, slot))
    }
}
impl PartRootProvider for Providers<'_> {
    fn compute_part_root(&self, slot: u64) -> Hash256 {
        futures::executor::block_on(part_root_for_slot(self.st, slot))
    }
}
impl TxRootProvider for Providers<'_> {
    fn compute_txroot(&self, slot: u64) -> Hash256 {
        // Compute txroot from ticket leaves at the given slot by
        // building a Merkle over Tag("obex.txid.leaf") || txid,
        // sorted by txid ascending.
        let map = futures::executor::block_on(self.st.ticket_leaves.read());
        let leaves_concat = map.get(&slot).cloned().unwrap_or_default();
        if leaves_concat.is_empty() {
            return h_tag(constants::TAG_MERKLE_EMPTY, &[]);
        }
        // Extract txids (bytes 64..96 in each leaf of length 216)
        let mut txids: Vec<[u8; 32]> = Vec::with_capacity(leaves_concat.len());
        for leaf in &leaves_concat {
            if leaf.len() < 96 {
                continue;
            }
            let mut txid = [0u8; 32];
            txid.copy_from_slice(&leaf[64..96]);
            txids.push(txid);
        }
        txids.sort_by(|a, b| a.as_slice().cmp(b.as_slice()));
        txids.dedup();
        let txid_leaves: Vec<Vec<u8>> = txids
            .iter()
            .map(|xid| {
                let mut b = Vec::with_capacity(64);
                b.extend_from_slice(&h_tag(constants::TAG_TXID_LEAF, &[]));
                b.extend_from_slice(xid);
                b
            })
            .collect();
        merkle_root(&txid_leaves)
    }
}

async fn ticket_root_for_slot(st: &AppState, slot: u64) -> Hash256 {
    let t0 = Instant::now();
    let map = st.ticket_leaves.read().await;
    let leaves = map.get(&slot).cloned().unwrap_or_default();
    let root = merkle_root(&leaves);
    let dt_ms = t0.elapsed().as_millis() as u64;
    st.metrics
        .root_build_ms_total
        .fetch_add(dt_ms, Ordering::Relaxed);
    st.metrics
        .root_build_count
        .fetch_add(1, Ordering::Relaxed);
    root
}

async fn part_root_for_slot(st: &AppState, slot: u64) -> Hash256 {
    let t0 = Instant::now();
    let map = st.partrecs.read().await;
    let vrf = Rfc9381Vrf;
    let mut pks: Vec<[u8; 32]> = Vec::new();
    for ((s, _pk), bytes) in map.iter() {
        if *s != slot {
            continue;
        }
        if let Ok(rec) = decode_partrec(bytes) {
            // Need parent_id for alpha. Retrieve parent header.
            let parent_id = {
                let hdrs = st.headers.read().await;
                hdrs.get(&slot.wrapping_sub(1))
                    .map(|h| obex_header_id(h))
                    .unwrap_or([0u8; 32])
            };
            let t1 = Instant::now();
            if obex_verify_partrec(&rec, slot, &parent_id, &vrf) {
                let dt_ms = t1.elapsed().as_millis() as u64;
                st.metrics
                    .alpha_i_verify_ms_total
                    .fetch_add(dt_ms, Ordering::Relaxed);
                st.metrics
                    .alpha_i_verify_count
                    .fetch_add(1, Ordering::Relaxed);
                pks.push(rec.pk_ed25519);
            }
        }
    }
    pks.sort_unstable();
    pks.dedup();
    let leaves: Vec<Vec<u8>> = pks
        .iter()
        .map(|pk| {
            let mut b = Vec::with_capacity(64);
            b.extend_from_slice(&h_tag(constants::TAG_PART_LEAF, &[]));
            b.extend_from_slice(pk);
            b
        })
        .collect();
    let root = merkle_root(&leaves);
    let dt_ms = t0.elapsed().as_millis() as u64;
    st.metrics
        .root_build_ms_total
        .fetch_add(dt_ms, Ordering::Relaxed);
    st.metrics
        .root_build_count
        .fetch_add(1, Ordering::Relaxed);
    root
}

struct Rfc9381Vrf;
impl EcVrfVerifier for Rfc9381Vrf {
    fn verify(&self, vrf_pubkey: &[u8; 32], alpha: &Hash256, vrf_proof: &[u8]) -> Option<Vec<u8>> {
        if vrf_proof.len() != 80 {
            return None;
        }
        use sha2::Sha512;
        use vrf_rfc9381::{
            ec::edwards25519::{tai::EdVrfEdwards25519TaiPublicKey, EdVrfProof},
            Verifier as _,
        };
        let vk = EdVrfEdwards25519TaiPublicKey::from_slice(vrf_pubkey).ok()?;
        let mut pi80 = [0u8; 80];
        pi80.copy_from_slice(vrf_proof);
        let proof = <EdVrfProof as vrf_rfc9381::Proof<Sha512>>::decode_pi(&pi80).ok()?;
        let out = vk.verify(alpha, proof).ok()?;
        Some(out.as_slice().to_vec())
    }
}

async fn post_header(
    State(st): State<AppState>,
    Json(dto): Json<HeaderDto>,
) -> Result<String, (StatusCode, String)> {
    // must know parent
    let t0 = Instant::now();
    let parent_slot = dto
        .slot
        .checked_sub(1)
        .ok_or((StatusCode::BAD_REQUEST, "slot must be > 0".to_owned()))?;
    let parent = {
        let map = st.headers.read().await;
        map.get(&parent_slot).cloned().ok_or((
            StatusCode::PRECONDITION_FAILED,
            "parent header missing".to_owned(),
        ))?
    };
    // validate equalities
    let h = dto.clone().into_header();
    let providers = Providers { st: &st };
    let res = validate_header(
        &h,
        &parent,
        &providers,
        &providers,
        &providers,
        OBEX_ALPHA_II_VERSION,
    );
    let dt_ms = t0.elapsed().as_millis() as u64;
    st.metrics
        .header_validate_ms_total
        .fetch_add(dt_ms, Ordering::Relaxed);
    st.metrics
        .header_validate_count
        .fetch_add(1, Ordering::Relaxed);
    if let Err(e) = res {
        log_json(
            "warn",
            1000,
            "header_rejected",
            serde_json::json!({"slot": h.slot, "reason": format!("{:?}", e)})
        );
        st.metrics
            .headers_rejected_total
            .fetch_add(1, Ordering::Relaxed);
        return Err((StatusCode::UNPROCESSABLE_ENTITY, format!("{:?}", e)));
    } else {
        log_json(
            "info",
            1001,
            "header_accepted",
            serde_json::json!({"slot": h.slot})
        );
        st.metrics
            .headers_validated_total
            .fetch_add(1, Ordering::Relaxed);
    }
    st.headers.write().await.insert(h.slot, h);

    // Header-first pull: if roots are non-empty, fetch bodies to verify locally.
    let need_part = !bool::from(dto.part_root.ct_eq(&h_tag(constants::TAG_MERKLE_EMPTY, &[])));
    let need_tix = !bool::from(dto.ticket_root.ct_eq(&h_tag(constants::TAG_MERKLE_EMPTY, &[])));
    if need_part || need_tix {
        let peers = st.peers.clone();
        let timeout = st.http_timeout_ms;
        let slot = dto.slot;
        tokio::spawn(async move {
            let client = reqwest::Client::builder()
                .timeout(Duration::from_millis(timeout))
                .build()
                .expect("client");
            for base in peers.iter() {
                let base = base.trim_end_matches('/');
                let mut ok = true;
                if need_part {
                    // pull α‑I per unique pk is expensive; placeholder: pull nothing (requires index)
                }
                if need_tix {
                    let url = format!("{}/alpha_iii/{}", base, slot);
                    match client.get(url).send().await {
                        Ok(resp) if resp.status().is_success() => {
                            match resp.bytes().await {
                                Ok(bytes) => {
                                    log_json("info", 1100, "fetched_alpha_iii", serde_json::json!({"peer": base, "slot": slot, "len": bytes.len()}));
                                }
                                Err(e) => {
                                    ok = false;
                                    log_json("warn", 2101, "fetch_body_read_err", serde_json::json!({"peer": base, "slot": slot, "err": e.to_string()}));
                                }
                            }
                        }
                        Ok(resp) => {
                            ok = false;
                            log_json("warn", 2100, "fetch_body_http_err", serde_json::json!({"peer": base, "slot": slot, "status": resp.status().as_u16()}));
                        }
                        Err(e) => {
                            ok = false;
                            log_json("warn", 2102, "fetch_body_net_err", serde_json::json!({"peer": base, "slot": slot, "err": e.to_string()}));
                        }
                    }
                }
                if ok {
                    // success path
                }
            }
        });
    }
    put_header_db(&st.db, &dto.into_header())
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e))?;
    Ok("ok".to_owned())
}

// Build and persist the next header deterministically from current state
async fn post_advance(State(st): State<AppState>) -> Result<Json<HeaderDto>, (StatusCode, String)> {
    // Find current max slot
    let (slot_max, parent) = {
        let map = st.headers.read().await;
        let Some((&mx, h)) = map.iter().max_by_key(|(k, _)| *k) else {
            return Err((StatusCode::PRECONDITION_FAILED, "no parent header".to_owned()));
        };
        (mx, h.clone())
    };
    let next_slot = slot_max.checked_add(1).ok_or((StatusCode::BAD_REQUEST, "slot overflow".to_owned()))?;
    let parent_id = obex_header_id(&parent);
    let seed_commit = h_tag(constants::TAG_SLOT_SEED, &[&parent_id, &le_bytes::<8>(u128::from(next_slot))]);
    let y_core = [3u8; 32];
    let y_edge = h_tag(constants::TAG_VDF_EDGE, &[&y_core]);
    // Compute roots from current store
    let providers = Providers { st: &st };
    let ticket_root = providers.compute_ticket_root(next_slot);
    let part_root = providers.compute_part_root(next_slot);
    let txroot_prev = providers.compute_txroot(slot_max);
    let h = Header {
        parent_id,
        slot: next_slot,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit,
        vdf_y_core: y_core,
        vdf_y_edge: y_edge,
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root,
        part_root,
        txroot_prev,
    };
    let t0 = Instant::now();
    validate_header(&h, &parent, &providers, &providers, &providers, OBEX_ALPHA_II_VERSION)
        .map_err(|e| (StatusCode::UNPROCESSABLE_ENTITY, format!("{:?}", e)))?;
    log_json(
        "info",
        1002,
        "header_built",
        serde_json::json!({"slot": h.slot})
    );
    let dt_ms = t0.elapsed().as_millis() as u64;
    st.metrics
        .header_validate_ms_total
        .fetch_add(dt_ms, Ordering::Relaxed);
    st.metrics
        .header_validate_count
        .fetch_add(1, Ordering::Relaxed);
    st.metrics
        .headers_validated_total
        .fetch_add(1, Ordering::Relaxed);
    st.headers.write().await.insert(h.slot, h.clone());
    put_header_db(&st.db, &h).map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e))?;
    Ok(Json(HeaderDto::from_header(&h)))
}

fn put_header_db(db: &Db, h: &Header) -> Result<(), String> {
    let key = header_key(h.slot);
    let val = serialize_header(h);
    db.insert(key, val).map_err(|e| e.to_string())?;
    db.flush().map_err(|e| e.to_string())?;
    Ok(())
}

fn get_header_db(db: &Db, slot: u64) -> Result<Option<Header>, String> {
    let key = header_key(slot);
    if let Some(ivec) = db.get(key).map_err(|e| e.to_string())? {
        let bytes = ivec.to_vec();
        let h = deserialize_header(&bytes).map_err(|_| "decode header".to_owned())?;
        Ok(Some(h))
    } else {
        Ok(None)
    }
}

fn header_key(slot: u64) -> [u8; 8] {
    u64::to_le_bytes(slot)
}

fn put_partrec_db(db: &Db, slot: u64, pk: &[u8; 32], bytes: &[u8]) -> Result<(), String> {
    let mut key = Vec::with_capacity(8 + 32 + 4);
    key.extend_from_slice(&u64::to_le_bytes(slot));
    key.extend_from_slice(pk);
    key.extend_from_slice(b"part");
    db.insert(key, bytes).map_err(|e| e.to_string())?;
    db.flush().map_err(|e| e.to_string())?;
    Ok(())
}

fn put_ticket_leaves_db(db: &Db, slot: u64, concat: &[u8]) -> Result<(), String> {
    let mut key = Vec::with_capacity(8 + 5);
    key.extend_from_slice(&u64::to_le_bytes(slot));
    key.extend_from_slice(b"tixls");
    db.insert(key, concat).map_err(|e| e.to_string())?;
    db.flush().map_err(|e| e.to_string())?;
    Ok(())
}

async fn metrics(State(st): State<AppState>) -> String {
    metrics_text(&st.metrics)
}

async fn healthz(State(st): State<AppState>) -> Result<String, (StatusCode, String)> {
    let has_genesis = { st.headers.read().await.contains_key(&0) };
    if !has_genesis {
        return Err((StatusCode::SERVICE_UNAVAILABLE, "missing genesis".to_owned()));
    }
    Ok("ok".to_owned())
}

'PROJECT_ROOT'>obex-alpha>crates>obex_primitives>Cargo.toml
[package]
name = "obex_primitives"
version = "1.0.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[dependencies]
sha3 = "0.10.8"
subtle = "2.6.1"
thiserror = "1.0"



'PROJECT_ROOT'>obex-alpha>crates>obex_primitives>src>lib.rs
#![forbid(unsafe_code)]
#![deny(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(
    clippy::module_name_repetitions,
    clippy::missing_errors_doc,
    clippy::missing_panics_doc,
    clippy::result_large_err
)]

//! OBEX primitives: domain-tagged SHA3-256 hashing, fixed-width LE encodings, binary Merkle.

use sha3::{Digest, Sha3_256};
use subtle::ConstantTimeEq;

pub type Hash256 = [u8; 32];

pub mod constants {
    // Tag registry (must match CONSENSUS_SPEC.md)
    pub const TAG_MERKLE_LEAF: &str = "obex.merkle.leaf";
    pub const TAG_MERKLE_NODE: &str = "obex.merkle.node";
    pub const TAG_MERKLE_EMPTY: &str = "obex.merkle.empty";
    pub const TAG_ALPHA: &str = "obex.alpha";
    pub const TAG_PART_LEAF: &str = "obex.part.leaf";
    pub const TAG_PARTREC: &str = "obex.partrec";
    pub const TAG_SEED: &str = "obex.seed";
    pub const TAG_L0: &str = "obex.l0";
    pub const TAG_LBL: &str = "obex.lbl";
    pub const TAG_IDX: &str = "obex.idx";
    pub const TAG_CHAL: &str = "obex.chal";
    pub const TAG_VRFY: &str = "obex.vrfy";
    pub const TAG_HEADER_ID: &str = "obex.header.id";
    pub const TAG_SLOT_SEED: &str = "obex.slot.seed";
    pub const TAG_VDF_YCORE: &str = "obex.vdf.ycore";
    pub const TAG_VDF_EDGE: &str = "obex.vdf.edge";
    pub const TAG_TX_ACCESS: &str = "obex.tx.access";
    pub const TAG_TX_BODY_V1: &str = "obex.tx.body.v1";
    pub const TAG_TX_ID: &str = "obex.tx.id";
    pub const TAG_TX_COMMIT: &str = "obex.tx.commit";
    pub const TAG_TX_SIG: &str = "obex.tx.sig";
    pub const TAG_TXID_LEAF: &str = "obex.txid.leaf";
    pub const TAG_TICKET_ID: &str = "obex.ticket.id";
    pub const TAG_TICKET_LEAF: &str = "obex.ticket.leaf";
    pub const TAG_SYS_TX: &str = "obex.sys.tx";
    pub const TAG_REWARD_DRAW: &str = "obex.reward.draw";
    pub const TAG_REWARD_RANK: &str = "obex.reward.rank";
}

#[must_use]
pub fn le_bytes<const W: usize>(mut x: u128) -> [u8; W] {
    let mut out = [0u8; W];
    let mut i = 0usize;
    while i < W {
        out[i] = (x & 0xFF) as u8;
        x >>= 8;
        i += 1;
    }
    out
}

#[must_use]
pub fn u64_from_le(b: &[u8]) -> u64 {
    let mut x: u64 = 0;
    let mut i = 0usize;
    while i < 8 && i < b.len() {
        x |= u64::from(b[i]) << (8 * i as u64);
        i += 1;
    }
    x
}

#[must_use]
pub fn h_tag(tag: &str, parts: &[&[u8]]) -> Hash256 {
    debug_assert!(tag.starts_with("obex."));
    let mut hasher = Sha3_256::new();
    hasher.update(tag.as_bytes());
    for p in parts {
        hasher.update(le_bytes::<8>(p.len() as u128));
        hasher.update(p);
    }
    let digest = hasher.finalize();
    let mut out = [0u8; 32];
    out.copy_from_slice(&digest);
    out
}

#[must_use]
pub fn ct_eq_hash(a: &Hash256, b: &Hash256) -> bool {
    a.ct_eq(b).into()
}

#[must_use]
pub fn merkle_leaf(payload: &[u8]) -> Hash256 {
    h_tag(constants::TAG_MERKLE_LEAF, &[payload])
}

#[must_use]
pub fn merkle_node(l: &Hash256, r: &Hash256) -> Hash256 {
    let mut cat = [0u8; 64];
    cat[..32].copy_from_slice(l);
    cat[32..].copy_from_slice(r);
    h_tag(constants::TAG_MERKLE_NODE, &[&cat])
}

#[must_use]
pub fn merkle_root(leaves_payload: &[Vec<u8>]) -> Hash256 {
    if leaves_payload.is_empty() {
        return h_tag(constants::TAG_MERKLE_EMPTY, &[]);
    }
    let mut level: Vec<Hash256> = leaves_payload.iter().map(|p| merkle_leaf(p)).collect();
    while level.len() > 1 {
        if level.len() % 2 == 1 {
            if let Some(last) = level.last().copied() {
                level.push(last);
            }
        }
        let mut next: Vec<Hash256> = Vec::with_capacity(level.len() / 2);
        let mut i = 0usize;
        while i < level.len() {
            next.push(merkle_node(&level[i], &level[i + 1]));
            i += 2;
        }
        level = next;
    }
    level[0]
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct MerklePath {
    pub siblings: Vec<Hash256>,
    pub index: u64,
}

#[must_use]
pub fn merkle_verify_leaf(root: &Hash256, leaf_payload: &[u8], path: &MerklePath) -> bool {
    let mut h = merkle_leaf(leaf_payload);
    let mut idx = path.index;
    for sib in &path.siblings {
        h = if idx & 1 == 0 {
            merkle_node(&h, sib)
        } else {
            merkle_node(sib, &h)
        };
        idx >>= 1;
    }
    ct_eq_hash(root, &h)
}

'PROJECT_ROOT'>obex-alpha>crates>obex_tool>Cargo.toml
[package]
name = "obex_tool"
version = "1.0.0"
edition = "2021"
license = "MIT OR Apache-2.0"

[dependencies]
obex_primitives = { path = "../obex_primitives" }
obex_alpha_i = { path = "../obex_alpha_i" }
obex_alpha_ii = { path = "../obex_alpha_ii" }
obex_alpha_iii = { path = "../obex_alpha_iii" }
hex = "0.4"
clap = { version = "4.5", features = ["derive"] }
reqwest = { version = "0.12", features = ["json", "blocking"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"



'PROJECT_ROOT'>obex-alpha>crates>obex_tool>src>main.rs
#![forbid(unsafe_code)]
#![deny(warnings)]

use clap::{Parser, Subcommand};
use obex_alpha_i::{decode_partrec, encode_partrec};
use obex_alpha_ii::{obex_header_id, serialize_header, Header, OBEX_ALPHA_II_VERSION};
use obex_alpha_iii::{enc_ticket_leaf, TicketRecord};
use obex_primitives::merkle_root;
use obex_primitives::{constants, h_tag, le_bytes};
use std::{fs, path::PathBuf};

#[derive(Parser)]
#[command(name = "obex-tool")]
#[command(about = "OBEX Alpha tooling", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Re-encode a canonical ObexPartRec and print length
    PartrecLen {
        #[arg(value_name = "HEX")]
        hex: String,
    },
    /// Generate beacon v1 and header goldens into --out directory
    GenGoldens {
        #[arg(long)]
        out: PathBuf,
    },
    /// Run a short burn-in across N nodes to check HeaderID divergence
    BurnIn {
        #[arg(long, default_value_t = 1000)]
        slots: u64,
        #[arg(long, value_delimiter = ',')]
        nodes: Vec<String>,
    },
}

fn main() {
    let cli = Cli::parse();
    match cli.command {
        Commands::PartrecLen { hex } => {
            let bytes = hex::decode(hex).expect("hex");
            let rec = decode_partrec(&bytes).expect("decode");
            let enc = encode_partrec(&rec).expect("encode");
            println!("{}", enc.len());
        }
        Commands::GenGoldens { out } => {
            fs::create_dir_all(out.join("vdf")).expect("mkdir vdf");
            fs::create_dir_all(out.join("header")).expect("mkdir header");
            fs::create_dir_all(out.join("alpha_i")).expect("mkdir alpha_i");
            fs::create_dir_all(out.join("alpha_iii")).expect("mkdir alpha_iii");
            // vdf set (beacon v1)
            let parent_id = [0u8; 32];
            let s = 1u64;
            let seed_commit = h_tag(
                constants::TAG_SLOT_SEED,
                &[&parent_id, &le_bytes::<8>(u128::from(s))],
            );
            let y_core = [3u8; 32];
            let y_edge = h_tag(constants::TAG_VDF_EDGE, &[&y_core]);
            fs::write(out.join("vdf/seed_commit.bin"), seed_commit).expect("write");
            fs::write(out.join("vdf/y_core.bin"), y_core).expect("write");
            fs::write(out.join("vdf/y_edge.bin"), y_edge).expect("write");
            fs::write(out.join("vdf/pi.bin"), &[] as &[u8]).expect("write");
            fs::write(out.join("vdf/ell.bin"), &[] as &[u8]).expect("write");
            // header set
            let header = Header {
                parent_id,
                slot: s,
                obex_version: OBEX_ALPHA_II_VERSION,
                seed_commit,
                vdf_y_core: y_core,
                vdf_y_edge: y_edge,
                vdf_pi: vec![],
                vdf_ell: vec![],
                ticket_root: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
                part_root: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
                txroot_prev: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
            };
            let hdr_bytes = serialize_header(&header);
            let hdr_id = obex_header_id(&header);
            fs::write(out.join("header/header.bin"), hdr_bytes).expect("write");
            fs::write(out.join("header/header_id.bin"), hdr_id).expect("write");
            // alpha_i: minimal partrec bytes (non-cryptographic; for decode/roundtrip tests)
            let mut challenges = Vec::new();
            for _ in 0..obex_alpha_i::CHALLENGES_Q {
                challenges.push(obex_alpha_i::ChallengeOpen {
                    idx: 1,
                    li: [9u8; 32],
                    pi: obex_alpha_i::MerklePathLite { siblings: vec![] },
                    lim1: [10u8; 32],
                    pim1: obex_alpha_i::MerklePathLite { siblings: vec![] },
                    lj: [11u8; 32],
                    pj: obex_alpha_i::MerklePathLite { siblings: vec![] },
                    lk: [12u8; 32],
                    pk_: obex_alpha_i::MerklePathLite { siblings: vec![] },
                });
            }
            let rec = obex_alpha_i::ObexPartRec {
                version: obex_alpha_i::OBEX_ALPHA_I_VERSION,
                slot: s,
                pk_ed25519: [1u8; 32],
                vrf_pk: [2u8; 32],
                y_edge_prev: [3u8; 32],
                alpha: h_tag(
                    constants::TAG_ALPHA,
                    &[
                        &parent_id,
                        &le_bytes::<8>(u128::from(s)),
                        &[3u8; 32],
                        &[2u8; 32],
                    ],
                ),
                vrf_y: vec![5u8; 64],
                vrf_pi: vec![6u8; 80],
                seed: h_tag(constants::TAG_SEED, &[&[3u8; 32], &[1u8; 32], &[5u8; 64]]),
                root: h_tag(constants::TAG_MERKLE_EMPTY, &[]),
                challenges,
                sig: [13u8; 64],
            };
            let partrec_bytes = obex_alpha_i::encode_partrec(&rec).expect("encode partrec");
            fs::write(out.join("alpha_i/partrec.bin"), &partrec_bytes).expect("write");
            // alpha_iii: ticket leaves and root
            let rec3 = TicketRecord {
                ticket_id: [0u8; 32],
                txid: [1u8; 32],
                sender: [2u8; 32],
                nonce: 0,
                amount_u: 1000,
                fee_u: 10,
                s_admit: 1,
                s_exec: 1,
                commit_hash: [3u8; 32],
            };
            let leaves: Vec<Vec<u8>> = vec![enc_ticket_leaf(&rec3)];
            let root = merkle_root(&leaves);
            let mut concat = Vec::new();
            for l in &leaves {
                concat.extend_from_slice(l);
            }
            fs::write(out.join("alpha_iii/ticket_leaves.bin"), concat).expect("write");
            fs::write(out.join("alpha_iii/ticket_root.bin"), root).expect("write");
            // negatives
            let neg = out.join("negatives");
            fs::create_dir_all(&neg).expect("mkdir negatives");
            // 1) vdf y_edge mismatch
            let mut bad_edge = y_edge;
            bad_edge[0] ^= 1;
            fs::write(neg.join("vdf_bad_y_edge.bin"), bad_edge).expect("write");
            // 2) vdf non-empty pi
            fs::write(neg.join("vdf_nonempty_pi.bin"), vec![1u8]).expect("write");
            // 3) header with non-empty pi
            let mut bad_header = header.clone();
            bad_header.vdf_pi = vec![1u8];
            let bad_hdr_bytes = serialize_header(&bad_header);
            fs::write(neg.join("header_bad_pi.bin"), bad_hdr_bytes).expect("write");
            // 4) partrec truncated
            let mut trunc = partrec_bytes.clone();
            if !trunc.is_empty() {
                trunc.pop();
            }
            fs::write(neg.join("partrec_truncated.bin"), trunc).expect("write");
            println!("goldens (and negatives) written to {}", out.display());
        }
        Commands::BurnIn { slots, nodes } => {
            assert!(!nodes.is_empty(), "--nodes must list at least one base URL");
            // Fetch parent header (slot 0) from first node
            let client = reqwest::blocking::Client::new();
            let base = nodes[0].trim_end_matches('/');
            #[derive(serde::Deserialize)]
            struct HeaderDto {
                parent_id: [u8; 32],
                slot: u64,
                obex_version: u32,
                seed_commit: [u8; 32],
                vdf_y_core: [u8; 32],
                vdf_y_edge: [u8; 32],
                vdf_pi: Vec<u8>,
                vdf_ell: Vec<u8>,
                ticket_root: [u8; 32],
                part_root: [u8; 32],
                txroot_prev: [u8; 32],
            }
            impl From<HeaderDto> for Header {
                fn from(d: HeaderDto) -> Self {
                    Header {
                        parent_id: d.parent_id,
                        slot: d.slot,
                        obex_version: d.obex_version,
                        seed_commit: d.seed_commit,
                        vdf_y_core: d.vdf_y_core,
                        vdf_y_edge: d.vdf_y_edge,
                        vdf_pi: d.vdf_pi,
                        vdf_ell: d.vdf_ell,
                        ticket_root: d.ticket_root,
                        part_root: d.part_root,
                        txroot_prev: d.txroot_prev,
                    }
                }
            }
            let parent_dto: HeaderDto = client
                .get(format!("{}/header/0", base))
                .send()
                .expect("get parent")
                .json::<HeaderDto>()
                .expect("json dto");
            let parent: Header = parent_dto.into();
            let mut cur = parent;
            for s in 1..=slots {
                // Build trivial header with empty roots and beacon v1
                let seed_commit = obex_primitives::h_tag(
                    obex_primitives::constants::TAG_SLOT_SEED,
                    &[&obex_alpha_ii::obex_header_id(&cur), &obex_primitives::le_bytes::<8>(s as u128)],
                );
                let y_core = [3u8; 32];
                let y_edge = obex_primitives::h_tag(obex_primitives::constants::TAG_VDF_EDGE, &[&y_core]);
                let hdr = Header {
                    parent_id: obex_alpha_ii::obex_header_id(&cur),
                    slot: cur.slot + 1,
                    obex_version: OBEX_ALPHA_II_VERSION,
                    seed_commit,
                    vdf_y_core: y_core,
                    vdf_y_edge: y_edge,
                    vdf_pi: vec![],
                    vdf_ell: vec![],
                    ticket_root: obex_primitives::h_tag(obex_primitives::constants::TAG_MERKLE_EMPTY, &[]),
                    part_root: obex_primitives::h_tag(obex_primitives::constants::TAG_MERKLE_EMPTY, &[]),
                    txroot_prev: obex_primitives::h_tag(obex_primitives::constants::TAG_MERKLE_EMPTY, &[]),
                };
                let id0 = obex_alpha_ii::obex_header_id(&hdr);
                // Post to all nodes and fetch back
                for n in &nodes {
                    let b = n.trim_end_matches('/');
                    let dto = serde_json::json!({
                        "parent_id": hdr.parent_id,
                        "slot": hdr.slot,
                        "obex_version": hdr.obex_version,
                        "seed_commit": hdr.seed_commit,
                        "vdf_y_core": hdr.vdf_y_core,
                        "vdf_y_edge": hdr.vdf_y_edge,
                        "vdf_pi": hdr.vdf_pi,
                        "vdf_ell": hdr.vdf_ell,
                        "ticket_root": hdr.ticket_root,
                        "part_root": hdr.part_root,
                        "txroot_prev": hdr.txroot_prev,
                    });
                    client.post(format!("{}/header", b)).json(&dto).send().expect("post header");
                    let got_dto: HeaderDto = client
                        .get(format!("{}/header/{}", b, hdr.slot))
                        .send()
                        .expect("get header")
                        .json::<HeaderDto>()
                        .expect("json dto");
                    let back: Header = got_dto.into();
                    let idn = obex_alpha_ii::obex_header_id(&back);
                    assert_eq!(id0, idn, "HeaderID divergence at slot {} on {}", hdr.slot, b);
                }
                cur = hdr;
            }
            println!("burn-in complete: {} slots, {} nodes, zero divergence", slots, nodes.len());
        }
    }
}

'PROJECT_ROOT'>obex-alpha>genesis>genesis.toml
# OBEX Alpha — Testnet Genesis (Beacon v1)

network_id = "obex-alpha-testnet"

[versions]
alpha_i = 1
alpha_ii = 2
alpha_iii = 1
alpha_t = 1

[beacon]
# y_core is a 32-byte hex string (no 0x prefix)
y_core = "0000000000000000000000000000000000000000000000000000000000000003"
# For beacon v1, pi and ell are empty; y_edge = H("obex.vdf.edge", [y_core])

[genesis_header]
slot = 0
parent_id = "0000000000000000000000000000000000000000000000000000000000000000"
# ticket_root/part_root/txroot_prev default to empty Merkle root at runtime

'PROJECT_ROOT'>obex-alpha>scripts>devnet.ps1
$ErrorActionPreference = "Stop"

$repo = Split-Path -Parent $PSScriptRoot
Set-Location $repo

Write-Host "Building obex_node (release)..."
cargo build --release -p obex_node | Out-Host

New-Item -ItemType Directory -Force -Path (Join-Path $repo "data") | Out-Null

$pids = @()
for ($i = 1; $i -le 5; $i++) {
  $port = 8080 + $i
  $dir = Join-Path $repo ("data\node$($i)")
  New-Item -ItemType Directory -Force -Path $dir | Out-Null
  $exe = Join-Path $repo "target\release\obex_node.exe"
  $args = @("--listen", "127.0.0.1:$port", "--data-dir", $dir)
  $proc = Start-Process -FilePath $exe -ArgumentList $args -PassThru -WindowStyle Hidden
  $pids += $proc.Id
}

Set-Content -Path (Join-Path $PSScriptRoot ".devnet_pids.txt") -Value ($pids -join "`n")
Write-Host ("Nodes started on 8081-8085. PIDs: {0}" -f ($pids -join ', '))



'PROJECT_ROOT'>obex-alpha>scripts>stop-devnet.ps1
$ErrorActionPreference = "Stop"

$pidFile = Join-Path $PSScriptRoot ".devnet_pids.txt"
if (-Not (Test-Path $pidFile)) {
  Write-Host "No PID file found."
  exit 0
}
$pids = Get-Content $pidFile | Where-Object { $_ -match '^\d+$' }
foreach ($pid in $pids) {
  try {
    Stop-Process -Id [int]$pid -Force -ErrorAction SilentlyContinue
  } catch {}
}
Remove-Item $pidFile -ErrorAction SilentlyContinue
Write-Host "Devnet stopped."



'PROJECT_ROOT'>obex-alpha>tests>golden>alpha_i>partrec.bin
[BASE64]AQAAAAEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQECAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnHp87TiIqzY6YQKdejxAwcZwFgEl5jd+qM93ZygmpgFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYIID1EjhDRym+gI4yCRzvIwJvG/VD2ZQ9hJ83w4t0Q/yslShus1DxTd8j7IxEGbe5gPOXtPnEyGrPtKju2IoV+YAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAEAAAAAAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoAAAAACwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAQAAAAAAAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQAAAAAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgAAAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAABAAAAAAAAAAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAAAAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKAAAAAAsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAA0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0=
'PROJECT_ROOT'>obex-alpha>tests>golden>alpha_iii>ticket_leaves.bin
[BASE64]mTI4rrIg/vxAkXfpZaiIyDihYGMkHSgzChGjOkLKV9kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAAAAAAAAOgDAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMD
'PROJECT_ROOT'>obex-alpha>tests>golden>alpha_iii>ticket_root.bin
[BASE64]NEGsRwkz3MeWjfMGquFy1urS5is+DT7M3PMfl4O/4MU=
'PROJECT_ROOT'>obex-alpha>tests>golden>header>header.bin
[BASE64]AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAIAAAAADStM45saCBnPujrbuP4aXEJZ55SFAxgAORbOp6VZbAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDdPfPFfYK84SMyvlB/SFQJjDorTrDwPg6bcenQP9MKOYAAAAAAAAAACslShus1DxTd8j7IxEGbe5gPOXtPnEyGrPtKju2IoV+KyVKG6zUPFN3yPsjEQZt7mA85e0+cTIas+0qO7YihX4rJUobrNQ8U3fI+yMRBm3uYDzl7T5xMhqz7So7tiKFfg==
'PROJECT_ROOT'>obex-alpha>tests>golden>header>header_id.bin
[BASE64]f3cF1hP94DeS/At/VXNqLLzwbVKVH5alQODa+Fjf7VI=
'PROJECT_ROOT'>obex-alpha>tests>golden>vdf>ell.bin

'PROJECT_ROOT'>obex-alpha>tests>golden>vdf>pi.bin

'PROJECT_ROOT'>obex-alpha>tests>golden>vdf>seed_commit.bin
[BASE64]AA0rTOObGggZz7o627j+GlxCWeeUhQMYADkWzqelWWw=
'PROJECT_ROOT'>obex-alpha>tests>golden>vdf>y_core.bin

'PROJECT_ROOT'>obex-alpha>tests>golden>vdf>y_edge.bin
[BASE64]dPfPFfYK84SMyvlB/SFQJjDorTrDwPg6bcenQP9MKOY=

